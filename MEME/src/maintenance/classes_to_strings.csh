#!/bin/csh -f
#
# File:   classes_to_strings.csh
# Author: Brian Carlsen
#
# Remarks:  This script takes a classes_atoms.src file
#           and produces a strings.src file from it
#           It assumes $LVG_HOME is set
#
# 11/16/2011 BAC: convert awk to Perl for better use on Linux, and remove environment-specific path
# 10/20/2011 PM : Changed the awk setting
# 02/24/2009 BAC (1-GCLNT): Better error reporting and parallelization
# 10/29/2008 BAC (need ticket): Parallelize and optimize
# 09/08/2003 (4.2.0): Release to NLM
# 06/20/2003 (4.1.1): Use language field from classes_atoms.src
#                     instead of param
# 03/19/2003 (4.1.0): Ported to MEME4
#
# Version info
set release=4
set version="2.0"
set authority="BAC";
set date="06/20/2004";

#
# Set environment (if configured)
#
if ($?ENV_FILE == 1 && $?ENV_HOME == 1) then
    source $ENV_HOME/bin/env.csh
endif

#
# Change on release to NLM
#
setenv PATH "/bin:/usr/bin:/usr/local/bin"
set sed=sed
set sort="sort -T ."
set join=join

if ($?LVG_HOME == 0) then
    echo "ERROR: \$LVG_HOME must be set."
    exit 1
endif

if ($#argv > 0) then
    if ("-version" == $argv[1]) then
        echo "Release ${release}: version $version, $date ($authority)"
        exit 0
    else if ("$argv[1]" == "-v") then
        echo "$version"
        exit 0
    else if ("$argv[1]" == "--help" || "$argv[1]" == "-help") then
    cat <<EOF
 This script has the following usage:
   Usage: $0 <directory> <language>

    This script takes a directory containing a
    classes_atoms.src file and produces a strings.src
    file from it.

EOF
    exit 0
    endif
endif

if ($#argv != 2) then
    echo "Usage: $0 <directory> <language>"
    exit 1
endif

set dir=$1
if (!(-d $dir)) then
    echo "ERROR: $dir is not a directory."
    exit 1
endif

set lang=$21
set file=$dir/classes_atoms.src
if (!(-e $file)) then
    echo "ERROR: $file does not exist."
    exit 1
endif
echo "--------------------------------------------------------------"
echo "Starting `/bin/date`"
echo "--------------------------------------------------------------"
echo "LVG_HOME:        $LVG_HOME"
echo "language:   $lang (ignored, value taken from file)"
echo "file:       $file"
echo "dir:        $dir"

#
# Convert to
#    id|string|norm_string
# into
#    string_pre|string|norm_string_pre|norm_string|lc_pre|language

#
# Determine parallelism.  Divide into 6 parts if > 10000 lines
#
set lines = `cat $file | wc -l`
if ($lines < 100000) then
    set part = 100000
else
    set part = `echo "$lines 1000 + 6 / p q" | dc`
endif

#
# Get Unique string/lat combinations and split into parts
# string|language
#
echo "    Extracting unique string, language ...`/bin/date`"
$PATH_TO_PERL -ne 'chop; split /\|/; print "$_[7]|$_[12]\n";' $file | $sort -u |\
  split -l $part -  $dir/t$$

#
# Norm the strings but preserve the id number
# id|string|language|norm_string
#
# Use perl to make the strings.src format
# strings.src format
#
# The norm string for english strings is generated by running the
# string through luiNorm.  For foreign (non ENG) strings, luiNorm is
# useless so we duplicate the string into the norm string field.
# string|language|norm_string (same as string)
#
echo "    Generating strings.src format ...`/bin/date`"
foreach f ($dir/t$$*)
    ($PATH_TO_PERL -ne 'chop; split /\|/; print "$_[0]|$_[1]|$_[0]\n" if $_[1] ne "ENG"' $f; \
     $PATH_TO_PERL -ne 'chop; split /\|/; print "$_\n" if $_[1] eq "ENG"' $f |\
     $LVG_HOME/bin/luiNorm -t:1 -n) | $sed 's/-No Output-//' |\
    $PATH_TO_PERL -e 'unshift @INC,"$ENV{ENV_HOME}/bin"; require "env.pl"; \
        while(<>) {  chop; ($s,$lang,$ns)=split /\|/; \
        $_=substr($s,0,10)."|$s|".substr($ns,0,10)."|$ns|".lc(substr($s,0,10))."|$lang\n";\
        print;}' >! $f.strings &
end
wait
if ($status != 0) then
    echo "ERROR generating strings.src format"
    exit 1
endif

#
# Combine pieces (and sort)
#
$sort -o strings.src $dir/t$$*strings

#
# Cleanup
#
/bin/rm -f $dir/t$$* $dir/$$.norm

echo "--------------------------------------------------------------"
echo "Finished `/bin/date`"
echo "--------------------------------------------------------------"
