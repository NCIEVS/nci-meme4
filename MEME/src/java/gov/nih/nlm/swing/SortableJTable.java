/**
 * {@link JTable} that can be sorted by column. The sorter has a model (conforming to TableModel)
 * and itself implements TableModel. {@link TableSorter} does not store or copy
 * the data in the {@link TableModel}, instead it maintains an array of
 * integers which it keeps the same size as the number of rows in its
 * model. When the model changes it notifies the sorter that something
 * has changed eg. "rowsAdded" so that its internal array of integers
 * can be reallocated. As requests are made of the sorter (like
 * getValueAt(row, col) it redirects them to its model via the mapping
 * array. That way the {@link TableSorter} appears to hold another copy of the table
 * with the rows in a different order. The sorting algorthm used is stable
 * which means that it does not move around rows when its comparison
 * function returns 0 to denote that they are equivalent.
 *
 * @version 1.5 12/17/97
 * @author Philip Milne
 */
package gov.nih.nlm.swing;

// Imports for picking up mouse events from the JTable.
import javax.swing.DefaultListSelectionModel;
import javax.swing.JTable;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.table.TableModel;

/**
 * {@link JTable}  that supports sorting of columns. Uses a bunch of code
 * harvested from Sun's (<a href="java.sun.com"><code>java.sun.com</code></a>)
 * tutorials.  It creates a that can be sorted by clicking
 * on the column headers.  Any normal table model can be
 * passed to the constructor.
 */
public class SortableJTable extends JTable {

  //
  // Private Variables
  //
  private int selected_indexes[] = {};
  private int new_selected_indexes[] = {};
  private TableSorter ts;
  private boolean finished_construction = true;
  private boolean flag = true;
  private ListSelectionListener[] lsl = {};

  /**
   * Instantiates an empty {@link SortableJTable}.
   * It is generally a good idea to call {@link #setModel(TableModel)} if
   * you use this constructor.
   */
  public SortableJTable() {
    super();
    finished_construction = true;
  }

  /**
   * Instantiates a {@link SortableJTable} from the specified model.
   * @param tm the {@link TableModel}
   */
  public SortableJTable(TableModel tm) {
    super();
    ts = new TableSorter(tm);
    super.setModel(ts);
    ts.addMouseListenerToHeaderInTable(this);
    finished_construction = true;
  }

  /**
   * Sets the model for the table.
   * @param tm the {@link TableModel}
   */
  public void setModel(TableModel tm) {
    if (!finished_construction) {
      super.setModel(tm);
      return;
    }

    ts = new TableSorter(tm);
    ts.addMouseListenerToHeaderInTable(this);
    super.setModel(ts);

    /* BAC thinks the following code is useless
       super.setModel(tm);
       if(ts != null)
       ts.setModel(tm);
     */
  }

  /**
   * Resets the sorting mechanism to wait until a header is
   * clicked before sorting the table.
   */
  public void resetSort() {
    ts.resetSort();
  }

  /**
   * Maps the row index to the underlying model index.
   * The sorting algorithm does not actually re-order
   * the data in the model, but provides a mapping of
   * row indices to underlying data structure indices.
   * This mapping can be queried here.
   * @param i a row index in the current table
   * @return the index of the underlying table model
   *         corresonding to that row index.
   */
  public int mapIndex(int i) {
    int j = ts.mapIndex(i);
    return j;
  }

  /**
   * Maps a real index from the table model to its
   * current row index in the table. This is the reverse
   * operation of {@link #mapIndex(int)}.
   * @param i an index in the table model
   * @return the row index from the table corresponding to
   *         the specified index of the underlying model
   */
  public int reverseMapIndex(int i) {
    int j = ts.reverseMapIndex(i);
    return j;
  }

  /**
   * Called when the list selection changes.  This is important
   * for maintaining selections through a table sort.
   * @param e the {@link ListSelectionEvent}
   */
  public void valueChanged(ListSelectionEvent e) {
    super.valueChanged(e);
    if (flag) {
      selected_indexes = getSelectedRows();
      for (int i = 0; i < selected_indexes.length; i++) {
        selected_indexes[i] = ts.mapIndex(selected_indexes[i]);
      }
    }
  }

  /**
   * Handles table change events.
   * If the event was generated by a {@link TableSorter}, it
   * remaps the row selections to be consistent with the sort operation.
   * @param e the {@link TableModelEvent}
   */
  public void tableChanged(TableModelEvent e) {

    // Only process if we have finished instantiating the class
    if (!finished_construction) {
      return;
    }

    // We can do this to flag for TableSorter events
    if (e.getSource()instanceof TableSorter) {

      // Inform listeners that we are starting a sort
      // This is an opportunity to ignore any valueChanged
      // calls that occur as a result of the following code
      fireTableSortStarted();

      // locally, we want to ignore
      // valueChanged events while the
      // superclass handles the event
      flag = false;
      super.tableChanged(e);
      flag = true;

      // Copy selected_indexes
      new_selected_indexes = new int[selected_indexes.length];
      System.arraycopy(selected_indexes, 0, new_selected_indexes,
                       0, selected_indexes.length);

      // Map the selected indexes through table sorter
      for (int i = 0; i < selected_indexes.length; i++) {
        new_selected_indexes[i] =
            ts.reverseMapIndex(new_selected_indexes[i]);

      }
      ListSelectionModel lsm = getSelectionModel();

      // Try to process it all as one event
      // just in case listener is not TableSortListener
      lsm.setValueIsAdjusting(true);

      // Clear selection
      lsm.clearSelection();

      // Mark new selections
      //   Each addSelectionInterval call will
      //   produce a valueChanged() call in *this* class
      //
      for (int i = 0; i < new_selected_indexes.length; i++) {
        lsm.addSelectionInterval(new_selected_indexes[i],
                                 new_selected_indexes[i]);

        // Finish event
      }
      lsm.setValueIsAdjusting(false);

      // Inform listeners that table sort is done
      // handling of valueChanged should be re-enabled
      fireTableSortFinished();

      // debug
      // ts.dump();

    } else {

      // No table sort, just handle event as normal

      // locally, we want to ignore
      // valueChanged events while the
      // superclass handles the event
      flag = false;
      super.tableChanged(e);
      flag = true;
    }

  }

  /**
   * Adds the specified {@link TableSortListener}.
   * @param tsl the {@link TableSortListener}
   */
  public void addTableSortListener(TableSortListener tsl) {
    listenerList.add(TableSortListener.class, tsl);
  }

  /**
   * Removes the specified {@link TableSortListener}
   * @param tsl the {@link TableSortListener}
   */
  public void removeTableSortListener(TableSortListener tsl) {
    listenerList.remove(TableSortListener.class, tsl);
  }

  //
  // Private Methods
  //

  /**
   * Informs listeners that a table sort has started.
   */
  protected void fireTableSortStarted() {
    lsl = (ListSelectionListener[])
        ( ( (DefaultListSelectionModel) getSelectionModel()).
         getListeners(ListSelectionListener.class));
    for (int i = 0; i < lsl.length; i++) {
      this.getSelectionModel().removeListSelectionListener(lsl[i]);
    }
  }

  /**
   * Informs listeners that a table sort has finished.
   */
  protected void fireTableSortFinished() {
    for (int i = 0; i < lsl.length; i++) {
      this.getSelectionModel().addListSelectionListener(lsl[i]);
    }
  }

}
