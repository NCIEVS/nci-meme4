new src integrities|select concept_id_1 as concept_id, concept_id_2, relationship_id, source from relationships where relationship_level='S' and atom_id_1 in (select atom_id from classes where source='SRC') and atom_id_2 in (select atom_id from classes where source='SRC') and source !='SRC'|SRC rels must be owned by SRC|N|Relationships between SRC atoms must be owned by the SRC source.  This check identifies cases that are not.  Fix by setting the source to SRC.  This check was added to catch a case of a single LNC <tt>version_of</tt> relationship connecting an SRC/VPT with an SRC/RPT.|0|||
source specific integrities|select source from source_rank where source_family != 'CPT' and source in (select current_name from source_version where source='HCPT')|HCPT has CPT source family|N|The current HCPT version should list CPT as its source family.|0|||
other referential integrities|select /*+ PARALLEL(r) */ relationship_id from relationships r where tobereleased NOT IN (select tobereleased from tobereleased_rank)|Invalid tobereleased field (R)|N|Every atom must have a <tt>tobereleased</tt> field found in tobereleased_rank.  This query returns <tt>relationship_id</tt>'s from the relationships table where the <tt>tobereleased</tt> field is not in the table tobereleased_rank.|0|||
other referential integrities|select /*+ PARALLEL(cs) */ concept_id from concept_status cs where tobereleased NOT IN (select tobereleased from tobereleased_rank)|Invalid tobereleased field (CS)|Y|Every concept must have a <tt>tobereleased</tt> field found in tobereleased_rank.  This query returns <tt>concept_id</tt>'s from the concept_status table where the <tt>tobereleased</tt> field is not in the table tobereleased_rank.|0|||
other referential integrities|select /*+ PARALLEL(c) */ atom_id from classes c where tobereleased NOT IN (select tobereleased from tobereleased_rank)|Invalid tobereleased field (C)|N|Every atom must have a <tt>tobereleased</tt> field found in tobereleased_rank.  This query returns <tt>atom_id</tt>'s from the classes table where the <tt>tobereleased</tt> field is not in the table tobereleased_rank.|0|||
other referential integrities|select relationship_attribute,inverse_rel_attribute from inverse_rel_attributes minus select inverse_rel_attribute,relationship_attribute from inverse_rel_attributes|Mismatched inverse_rel_attributes|N|Every <tt>relationship_attribute</tt> in the table inverse_rel_attributes must have a corresponding <tt>inverse_rel_attribute</tt>.  This query return the <tt>relationship_attribute</tt> and the <tt>inverse_rel_attribute</tt> fields that violate this condition.|0|||
other referential integrities|select atom_id, source, termgroup, concept_id from classes where source !=substr(termgroup,0,instr(termgroup,'/')-1) and tobereleased in ('Y','y')|Rows in classes source-termgroup mismatch|Y|The <tt>termgroup</tt> field for an atom must match its corresponding <tt>source</tt>.  This query returns <tt>concept_id</tt>'s and other fields from the classes table that violate this condition.|0|||
other referential integrities|select concept_id from classes where termgroup NOT IN (select termgroup from termgroup_rank)|Rows in classes with invalid termgroups|Y|Every <tt>termgroup</tt> in the classes table must be present and ranked in the termgroup_rank table.  This query returns <tt>concept_id</tt>'s where this condition is violated.|0|||
other referential integrities|select /*+ parallel(r) */ relationship_id, source from relationships r where relationship_level='S' and tobereleased in ('Y','y') and source NOT IN (select current_name from source_version) and source not like 'E-%' and source not in (select a.source from source_rank a, source_version b where a.normalized_source = b.current_name and a.source != a.normalized_source)|S level relationships with invalid source|N|Every releasable S level relationship must have its <tt>source</tt> field listed as a current version in <tt>source_version</tt>.  This query returns <tt>relationship_id</tt>'s where this condition is violated.|0|||
core table semantics|select concept_id,atom_id,source from classes where atom_id in (select to_number(substr(rank,instr(rank,'/')+1)) from (select /*+ PARALLEL(a) */ max(concat(a.rank,concat('/',atom_id))) as rank from classes a, source_rank b where a.source=b.source and restriction_level=0 group by concept_id)) and suppressible in ('E','Y') and termgroup not in ('MTH/MM','MTH/TM') and source not like 'NCBI%'|~ Suppressible preferred name (level 0)|Y|This check returns <tt>concept_id</tt>s of concepts whose highest ranking level 0 atom is suppressible.  These concepts should be edited to have a <tt>MTH/PN</tt> atom.

For the purposes of this check suppressible=O and NCBI atoms do not count.|0|||
other referential integrities|select distinct language from foreign_classes minus select lat from language|Invalid language in foreign_classes|N|The languages  in <tt>foreign_classes</tt> must appear in the <tt>language</tt> table.  To correct the problem, either add additional languages to <tt>language</tt> or update the values in <tt>foreign_classes</tt> (and inform the MRD).|0|||
other referential integrities|select distinct language from string_ui minus select lat from language|Invalid language in string_ui|N|The languages  in <tt>string_ui</tt> must appear in the <tt>language</tt> table.  To correct the problem, either add additional languages to <tt>language</tt> or update the values in <tt>string_ui</tt> (and inform the MRD).|0|||
other referential integrities|select /*+ PARALLEL(r) */ distinct relationship_attribute from relationships r where nvl(relationship_attribute,'null') not in (select nvl(relationship_attribute,'null') from inverse_rel_attributes)|Illegal relationship_attribute in relationships|N|Every <tt>relationship_attribute</tt> in the <tt>relationships</tt> must appear with an inverse in <tt>inverse_rel_attributes</tt>.  If it does not, this most likely means that a source was added which makes use of a <i>new</i> relationship attribute value and it was not added to <tt>inverse_rel_attributes</tt>.  To fix the problem, either add it to <tt>inverse_rel_attributes</tt> (with its inverse) or change the value in <tt>relationships</tt>|0|||
string unique identifier integrity|select lui from string_ui where norm_string like '%null%' and lower(string) not like '%null%'|Erroneous norm string|N|The normalized string should not contain the word null unless the string itself does.  This check stems from an error in the norm server that created erroneous norm strings where some words in the norm string were normalized to the literal string <tt>'null'</tt>.|0|||
new src integrities|select current_name from source_version a, source_rank b where current_name=b.source and b.source=b.normalized_source minus select atom_name from atoms a, classes b where a.atom_id=b.atom_id and b.source='SRC' and b.termgroup='SRC/VAB' and tobereleased in ('Y','y') and concept_id in (select concept_id from classes where source='SRC' and termgroup='SRC/VPT' and tobereleased in ('Y','y') group by concept_id having count(distinct sui)=1)|Source without exactly one SRC/VPT|N|Every source must have exactly one releasable SRC/VPT atom.  This query finds sources where this condition is violated.  There are two possible problems, and two corresponding fixes:<ol><li>If there are no SRC/VPT atoms, then add one</li><li>If there are multiple SRC/VPT atoms, remove duplicates</li></ol>|3|There are three exceptions:<ul>
<li>MTH has no versioned source</li>
<li>SRC has no versioned source</li>
<li>NLM-MED has no versioned source</li>
</ul>||
new src integrities| select concept_id from classes where tobereleased in ('Y','y') and source='SRC' and termgroup='SRC/VAB' minus (select concept_id_1 from relationships a, classes b where b.tobereleased in ('Y','y') and relationship_name='BT' and relationship_attribute='has_version' and concept_id_2 = b.concept_id and b.source='SRC' and b.termgroup='SRC/RAB' union select concept_id_2 from relationships a, classes b where b.tobereleased in ('Y','y') and relationship_name='NT' and relationship_attribute='version_of' and concept_id_1 = b.concept_id and b.source='SRC' and b.termgroup='SRC/RAB')|Versioned SRC without version_of rel|Y|Every current versioned SRC concept is required to have a <tt>version_of</tt> relationship to its respective root SRC concept.  This check returns concept ids that violate this condition.  To fix the problem, insert this relationship.|0|||
new src integrities|select previous_name from source_version,atoms a,classes b where a.atom_id=b.atom_id and b.tobereleased IN ('Y','y') and b.source='SRC' and termgroup='SRC/VAB' and atom_name=previous_name and previous_name IS NOT NULL|Obsolete sources with releasable SRC/VABs|N|Obsolete sources should not have relesable versioned SRC concepts.  This check returns the versioned source names corresponding to these SRC concepts.  The fix to this check is to make the versioned SRC concepts for those cases returned unreleasable.|0|||
new src integrities|select current_name from source_version a, source_rank b where b.source=current_name and b.source=normalized_source minus SELECT atom_name FROM atoms a,classes b where a.atom_id=b.atom_id and b.tobereleased IN ('Y','y') and b.source='SRC' and termgroup='SRC/VAB'|Current sources without releasable SRC/VABs|N|Current sources must have a releasable versioned SRC concept, represented by an <tt>SRC/VAB</tt>.  Violations of this check should be fixed by inserting the appropriate versioned SRC concept (and its accompanying data structure).|3|There are three adjustments.  Following are the adjustments and the reasons:
<ul>
  <li>MTH:  No versioned source</li>
  <li>SRC:  No versioned source</li>
  <li>NLM-MED: No versioned source</li></ul>||
new src integrities|select atom_name FROM atoms a,classes b where a.atom_id=b.atom_id and b.tobereleased IN ('Y','y') and b.source='SRC' and termgroup='SRC/VAB' minus select current_name from source_version|SRC/VAB missing from source_version|N|Every <tt>SRC/VAB</tt> atom name should be represented in the <tt>current_name</tt> field of <tt>source_version</tt>.  Violations of this check should be fixed by inserting or updating the appropriate data in <tt>source_version</tt>.|0|||
new src integrities|select atom_name FROM atoms a,classes b where a.atom_id=b.atom_id and b.tobereleased IN ('Y','y') and b.source='SRC' and termgroup='SRC/RAB' minus select source from source_version|SRC/RAB missing from source_version|N|Every <tt>SRC/RAB</tT> atom name must be represented in the <Tt>source</tt> field of <tt>source_version</tt>.  Violations of this check can be fixed by inserting the appropriate <tt>source_version</tt> data.|0|||
new src integrities|select a.source from source_version a, source_rank b where current_name=b.source and b.source=b.normalized_source minus select atom_name FROM atoms a,classes b where a.atom_id=b.atom_id and b.tobereleased IN ('Y','y') and b.source='SRC' and termgroup='SRC/RAB'|source_version minus SRC/RAB|N|Every value in the <tt>source</tt> field of <tt>source_version</tt> must be represented as an <tt>atom_name</tt> belonging to an <tt>SRC/RAB</tt> atom.  Violations of this check should be fixed either by removing the row from <tt>sourcE_version</tt> or inserting a new root SRC concept with a correct <tt>SRC/RAB</tt>.|0|||
unique identifier (ui) referential integrity|select atom_id from classes where source not in ('MTH','MTHICD9_2003','MTHICD9_2004','SRC','NOC97','MTHMST2001','NLM02','RXNORM_2005AA') and tobereleased in ('Y','y') minus select local_row_id from source_id_map where table_name='C'|Rows in classes minus source_id_map|N|This query retuns releasable <tt>atom_id</tt>'s from the classes table that do not match <tt>local_row_id</tt>'s in the source_id_map table for a <tt>table_name</tt> value of <tt>C</tt> (classes). (Note- The following sources are to be excluded from our search in classes for atom_id's: MTH, MTHICD9, SRC, NOC97, NLM02, RXNORM_2005AA).|9387|These cases were mistakenly lost when cleaning source_id_map.  They are not necessary unless other sources needed to map to these sources.
<pre>  COUNT(*) SOURCE
---------- --------------------
       732 ICD10AMAE_2000
      7424 ICD10AM_2000
       411 HHC2003
       809 NEU99
        11 SNMI98</pre>||
unique identifier (ui) referential integrity|select local_row_id from source_id_map where table_name='C' and source !='NLM02' minus (select atom_id from classes union select atom_id from foreign_classes)|Rows in source_id_map minus classes|N|This query retuns <tt>local_row_id</tt>'s from the source_id_map table for a table_name value of <tt>C</tt> (classes) that do not match any <tt>atom_id</tt>'s in the classes table.  Due to the churning of NLM02 atoms and the fact that they <i>are</i> assigned source atom ids, we have opted to exclude these rows from the check.|0|||
unique identifier (ui) referential integrity|select atom_id from classes minus select atom_id from atoms|Rows in classes minus atoms|N|This query retuns <tt>atom_id</tt>'s from the classes table that do not match any <tt>atom_id</tt>'s in the atoms table.|0|||
unique identifier (ui) referential integrity|select concept_id from concept_status minus select concept_id from classes|Rows in CS minus classes|Y|This query retuns any <tt>concept_id</tt>'s from the concept_status table that do not match to a <tt>concept_id</tt> in the classes table.  Use "Delete Empty Concepts" on the <a href="/cgi-lti-oracle/mid_maintenance.cgi">MID Maintenance</a> page to fix this.|0|||
unique identifier (ui) referential integrity|select concept_id from classes minus select concept_id from concept_status|Rows in classes minus CS|Y|This query retuns <tt>concept_id</tt>'s from the classes table that do not match any <tt>concept_id</tt>'s in the concept_status table.|0|||
unique identifier (ui) referential integrity|select atom_id_1 from (select atom_id_1 from relationships where relationship_level='S' union all select atom_id_2 from relationships where relationship_level='S') minus select atom_id from classes|S level relationships minus classes|N|This query retuns S level <tt>atom_id</tt>'s from the relationships table, either <tt>atom_id_1</tt> or <tt>atom_id_2</tt>, that do not match any <tt>atom_id</tt>'s in the classes table.|0|||
unique identifier (ui) referential integrity|select concept_id_1 from (select concept_id_1 from relationships where relationship_level='C' union all select concept_id_2 from relationships where relationship_level='C') minus select concept_id from classes|C level relationships minus classes|Y|This query retuns any C level <tt>concept_id</tt>'s from the relationships table, either concept_id_1 or concept_id_2, that do not match to a <tt>concept_id</tt> in the classes table.|0|||
unique identifier (ui) referential integrity|select row_id from atomic_actions where table_name='A' minus (select attribute_id from attributes union all select attribute_id from dead_attributes)|Rows in atomic_actions (A) minus A|N|This query retuns any <tt>row_id</tt>'s from the atomic_actions table with a <tt>table_name</tt> value equal to <tt>A</tt> (attributes) that do not match to an <tt>attribute_id</tt> in the attributes or dead_attributes tables.|0|||
unique identifier (ui) referential integrity|select row_id from atomic_actions where table_name='CR' minus (select relationship_id from context_relationships union all select relationship_id from dead_context_relationships)|Rows in atomic_actions (CR) minus CR|N|This query retuns any <tt>row_id</tt>'s from the atomic_actions table with a <tt>table_name</tt> value equal to <Tt>CR</tt> (context_relationships) that do not match to an <tt>relationship_id</tt> in the context_relationships or dead_context_relationships tables.|0|||
unique identifier (ui) referential integrity|select row_id from atomic_actions where table_name='CS' minus (select concept_id from concept_status union all select concept_id from dead_concept_status)|Rows in atomic_actions (CS) minus CS|Y|This query retuns any <tt>row_id</tt>'s from the atomic_actions table with a <tt>table_name</tt> value equal to <tt>CS</tt> (concept_status) that do not match to an <tt>concept_id</tt> in the concept_status or dead_concept_status tables.|0|||
string unique identifier integrity|select sui from classes minus select sui from string_ui|Rows in classes minus string_ui (SUI)|N|Every <tt>SUI</tt> in the classes table must be found in the string_ui table.  This query returns <tt>SUI</tt>'s than violate this condition.|0|||
string unique identifier integrity|select sui from dead_classes minus select sui from string_ui|Rows in dead_classes minus string_ui(SUI)|N|Every <tt>SUI</tt> in the dead_classes table must be found in the string_ui table.  This query returns <tt>SUI</tt>'s than violate this condition.|0|||
string unique identifier integrity|select lui from classes minus select lui from string_ui|Rows in classes minus string_ui(LUI)|N|Every <tt>LUI</tt> in the classes table must be found in the string_ui table.  This query returns <tt>LUI</tt>'s than violate this condition.|0|||
string unique identifier integrity|select lui from dead_classes minus select lui from string_ui|Rows in dead_classes minus string_ui (LUI)|N|Every <tt>LUI</tt> in the dead_classes table must be found in the string_ui table.  This query returns <tt>LUI</tt>'s than violate this condition.|0|||
other referential integrities|select /*+ PARALLEL(cr) */ relationship_id from context_relationships cr where released NOT IN (select released from released_rank)|Invalid released field (CR)|N|Every atom must have a <tt>released</tt> field found in released_rank.  This query returns <tt>relationhsip_id</tt>'s from the context_relationships table where the <tt>released</tt> field is not in the table released_rank.|0|||
other referential integrities|select /*+ PARALLEL(cs) */ concept_id from concept_status cs where released NOT IN (select released from released_rank)|Invalid released field (CS)|Y|Every atom must have a <tt>released</tt> field found in released_rank.  This query returns <tt>concept_id</tt>'s from the concept_status table where the <tt>released</tt> field is not in the table released_rank.|0|||
other referential integrities|select /*+ PARALLEL(a) */ distinct attribute_value from attributes a where attribute_name='SEMANTIC_TYPE' MINUS select semantic_type from semantic_types|Invalid semantic types (A)|N|Every <tt>attribute_value</tt> from the attributes table that has an <tt>attribute_name</tt> of SEMANTIC_TYPE must have a corresponding <tt>semantic_type</tt>, identical to the <tt>attribute_value</tt>, in the table semantic_types.    This query returns <tt>attribute_value<tt>'s that violate this condition.|0|||
other referential integrities|select /*+ PARALLEL(cs) */ concept_id from concept_status cs where status NOT IN (select status from level_status_rank where table_name='CS')|Invalid status field (CS)|Y|Every concept in the concept_status table must have a status in the level_status_rank table.  This query returns <tt>concept_id<tt>'s that violate this condition.|0|||
other referential integrities|select /*+ PARALLEL(c) */ atom_id from classes c where suppressible NOT IN (select suppressible from suppressible_rank)|Invalid suppressible field (C)|N|Every atom must have a <tt>suppressible</tt> field found in suppressible_rank.  This query returns <tt>atom_id</tt>'s from the classes table where the <tt>suppressible</tt> field is not in the table suppressible_rank.|0|||
other referential integrities|select /*+ PARALLEL(cr) */  relationship_id from context_relationships cr where suppressible NOT IN (select suppressible from suppressible_rank)|Invalid suppressible field (CR)|N|Every atom must have a <tt>suppressible</tt> field found in suppressible_rank.  This query returns <tt>relationship_id</tt>'s from the context_relationships table where the <tt>suppressible</tt> field is not in the table suppressible_rank.|0|||
unique identifier (ui) integrity|select /*+PARALLEL(a)*/ atui from attributes_ui a group by atui having count(*)>1|Duplicate ATUI (attributes_ui)|N|Finds cases where a single ATUI value appears more than once in
<tt>attributes_ui</tt>.  Violation
s are fixed like this:<ol>

<li> Find duplicate atuis
<pre>
drop table atui_dups;
create table atui_dups as select atui from attributes_ui
group by atui having count(*)>1;
</pre></li>
<li> Null them in attributes
<pre>
update attributes set atui  = null
where atui in (select * from atui_dups);
</pre></li>
<li> Clear from attributes_ui
<pre>
delete from attributes_ui where atui in
(select atui from atui_dups);
</pre>
</li>
<li> Re-assign
<pre>
update max_tab set max_id =
(select to_number(substr(max(atui),2)) from attributes_ui)
where table_name='ATUI';
exec meme_source_processing.assign_atuis('attributes','MTH',0);
</pre>
</li>
</ol>
|0|||
rxnorm semantics|select atom_id, concept_id from classes where source='NLM02' and termgroup in ('NLM02/IN') and tobereleased in ('Y','y') minus (select atom_id_2, concept_id_2 from relationships a, classes b where a.source='NLM02' and relationship_attribute in ('precise_ingredient_of','ingredient_of') and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SCDC' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|Ingredient without component|Y|Every ingredient must be connected to at least one component.  This check returns cases which are not.  To fix, click <a href="/cgi-lti-oracle/rxnorm_maintenance.cgi">here</a> and select "Disable Unused Atoms".|0|||
rxnorm semantics|select concept_id_1 as concept_id from relationships a, classes b where a.source='NLM02' and atom_id_1 = b.atom_id and b.source='NLM02' and termgroup = 'NLM02/IN' and relationship_attribute in ('ingredient_of','precise_ingredient_of') and b.tobereleased in ('Y','y') and a.tobereleased in ('Y','y') minus select concept_id from attributes where attribute_name='SEMANTIC_TYPE' and attribute_value in (select semantic_type from semantic_types where is_chem='Y')|Ingredient concept without chemical semantic type|Y|Every ingredient must have a chemical semantic type.  This check returns cases which do not.|0|||
rxnorm semantics|select concept_id from classes where tobereleased in ('Y','y') and source = 'NLM02' and termgroup in ('NLM02/SCD','NLM02/SBD','NLM02/SCDC','NLM02/SCDF','NLM02/SBDF') minus select concept_id from attributes where attribute_name='SEMANTIC_TYPE' and attribute_value='Clinical Drug'|Normal form or component without clinical drug sty|Y|Every normal form or component must have a semantic type of Clinical Drug.|0|||
rxnorm semantics|select concept_id from classes where source='NLM02' and termgroup='NLM02/SCDC' and tobereleased in ('Y','y') group by concept_id having count(distinct isui)>1|~ Component merges|Y|All normal form component atoms (NLM02/SCDC) with the same case-insensitive string must be in the same concept.  The inverse of this is also true, meaning any concept containing a component atom should have only component atoms with the same string.  This check identifies concepts containing component atoms with different case-insensitive strings.|0|||
rxnorm semantics|select distinct a.concept_id,b.concept_id from classes a, classes b where a.concept_id < b.concept_id and a.isui = b.isui and a.source='NLM02' and a.termgroup='NLM02/SCDC' and a.tobereleased in ('Y','y') and b.source='NLM02' and b.termgroup='NLM02/SCDC' and b.tobereleased in ('Y','y')|~ Component splits|N|All normal form component atoms (NLM02/SCDC) with the same case-insensitive string must be in the same concept.  This check finds pairs of concepts containing component atoms with the same case-insensitive string.|0|||
rxnorm semantics|select concept_id from classes where source='NLM02' and termgroup='NLM02/SCD' and tobereleased in ('Y','y') group by concept_id having count(distinct isui)>1|~ Normal form merges|Y|All normal form atoms (NLM02/SCD) with the same case-insensitive string must be in the same concept.  The inverse of this is also true, meaning any concept containing a normal form atom should have only normal form atoms with the same string.  This check identifies concepts containing normal form atoms with different case-insensitive strings.|0|||
rxnorm semantics|select distinct a.concept_id,b.concept_id from classes a, classes b where a.concept_id < b.concept_id and a.isui = b.isui and a.source='NLM02' and a.termgroup='NLM02/SCD' and a.tobereleased in ('Y','y') and b.source='NLM02' and b.termgroup='NLM02/SCD' and b.tobereleased in ('Y','y')|~ Normal form splits|N|All normal form atoms (NLM02/SCD) with the same case-insensitive string must be in the same concept.  This check finds pairs of concepts containing normal form atoms with the same case-insensitive string.|0|||
rxnorm semantics|select atom_id,concept_id from classes where source='NLM02' and termgroup in ('NLM02/SCD','NLM02/SBD') and tobereleased in ('Y','y') minus (select atom_id_1,concept_id_1 from relationships a, classes b where a.source='NLM02' and relationship_attribute='dose_form_of' and relationship_level='S' and atom_id_2 = b.atom_id and b.source like 'HL7%' and b.termgroup like 'HL7%/DF' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|Normal form without dose form|Y|Every normal form must be connected to a dose form.  An editor should review and fix cases which do not.|0|||
rxnorm semantics|select atom_id_1 as atom_id, concept_id_1 as concept_id from relationships a, classes b where a.source='NLM02' and relationship_attribute='dose_form_of' and relationship_level='S' and atom_id_2 = b.atom_id and b.source like 'HL7%' and b.termgroup like 'HL7%/DF' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y') group by atom_id_1,concept_id_1 having count(*) >1|Normal form with too many dose forms|Y|Every normal form must be connected to exactly one dose form.  This check returns cases which do not.|0|||
unique identifier (ui) integrity|select a.aui from foreign_classes a, classes b where a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and a.eng_atom_id = b.atom_id group by a.aui having count(distinct a.sui||a.source||a.tty||a.code||a.source_aui||a.source_cui||a.source_dui||b.concept_id)>1|Non-unique AUI (foreign)|N|No two releasable foreign classes should have the same AUI.|0|||
unique identifier (ui) integrity|select concept_id, atom_id from foreign_classes where aui is null and tobereleased in ('Y','y')|Releasable atom with null AUI (foreign)|Y|Every releasable foreign atom must have a non-null AUI.  Violations can be fixed by running MEME_SOURCE_PROCESSING.assign_auis.|0|||
core table semantics|select /*+ parallel(r) */ relationship_id,source from relationships r where relationship_level='C' and sg_type_1='CONCEPT_ID' and concept_id_1 != to_char(sg_id_1)  union select /*+ parallel(r) */ relationship_id,source from relationships r where relationship_level='C' and sg_type_2='CONCEPT_ID'  and concept_id_2 != to_char(sg_id_2)|C level rels with concept_id,sg_id out of sync|N|In C level relationships, sg_id_1 = concept_id_1 and sg_id_2 = concept_id_2 (as specified by sg_type_{1,2} = 'CONCEPT_ID').  This check returns cases where the ids are out of sync.|0||BEGIN meme_utility.drop_it('table','t_fix_$$'); execute immediate 'create table t_fix_$$ as select * from relationships where relationship_id in (select relationship_id from relationships where relationship_level=''C'' and sg_type_1=''CONCEPT_ID'' and concept_id_1 != to_char(sg_id_1) union select relationship_id from relationships where relationship_level=''C'' and sg_type_2=''CONCEPT_ID'' and concept_id_2 != to_char(sg_id_2))'; execute immediate 'update t_fix_$$ set rui=null,sg_id_1=to_char(concept_id_1),sg_id_2=to_char(concept_id_2)'; MEME_SOURCE_PROCESSING.assign_ruis('t_fix_$$','MTH',0); execute immediate 'delete from relationships where relationship_id in (select relationship_id from t_fix_$$)'; execute immediate 'insert into relationships select * from t_fix_$$'; END;|
core table semantics|select /*+ parallel(a) */attribute_id,source from attributes a where attribute_level='C' and sg_type='CONCEPT_ID'  and concept_id != to_char(sg_id) and tobereleased in ('Y','y')|C level atts with concept_id,sg_id out of sync|N|In C level attributes, sg_id = concept_id (as specified by sg_type = 'CONCEPT_ID').  This check returns cases where the ids are out of sync.|0|||
core table semantics|(select '1',atom_id_1,sg_id_1 from relationships  where relationship_level='S' and tobereleased in ('Y','y') and sg_type_1='AUI'  minus select '1',atom_id,aui from classes)  union  (select '2',atom_id_2,sg_id_2 from relationships  where tobereleased in ('Y','y' ) and relationship_level='S' and sg_type_2='AUI'  minus select '2',atom_id,aui from classes)|S level rels with aui,sg_id out of sync|N|In S level relatonships, sg_id_1,sg_id_2 = aui (as specified by sg_type_{1,2} = 'AUI').  This check returns cases where the ids are out of sync.|0|||
core table semantics|select /*+PARALLEL(a)*/ a.atom_id,a.sg_id from attributes a, classes b where a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y') and attribute_level='S' and sg_type='AUI' and a.atom_id = b.atom_id and b.aui != a.sg_id|S level atts with aui,sg_id out of sync|N|In S level attributes, sg_id = aui (as specified by sg_type = 'AUI').  This check returns cases where the ids are out of sync.|0|||
core table semantics|SELECT /*+ PARALLEL(fc) */ DISTINCT source FROM foreign_classes fc  WHERE source NOT IN (SELECT current_name FROM source_version)  AND tobereleased IN ('Y','y')|Releasable old version foreign sources|N|Non-current version foreign sources should be tbr=n.|0||UPDATE foreign_classes SET tobereleased = 'n' WHERE source NOT IN (SELECT current_name FROM source_version)|
core table semantics|SELECT /*+ PARALLEL(cr) */ relationship_id  FROM context_relationships cr  WHERE source NOT IN (SELECT current_name FROM source_version)  AND tobereleased IN ('Y','y')|Releasable old version context rels|N|Non-current version context relationships should be tbr=n.|0||DECLARE x number;   BEGIN     MEME_UTILITY.drop_it('table', 'tjfw_$$');     EXECUTE IMMEDIATE 'CREATE TABLE tjfw_$$ AS SELECT /*+ PARALLEL(cr) */ relationship_id as row_id FROM context_relationships cr WHERE source NOT IN (SELECT current_name FROM source_version)  AND tobereleased IN (''Y'',''y'')';  x:=MEME_BATCH_ACTIONS.macro_action(  action=>'T', id_type=>'CR', authority=>'L-JFW',  table_name=>'tjfw_$$', work_id=>0, status=>'R',  new_value=>'n');  MEME_UTILITY.drop_it('table', 'tjfw_$$');   END;|
core table semantics|select a.atom_id, a.concept_id from classes a, atoms b  where a.atom_id=b.atom_id  and source='MTH' and tty in ('TM','MM') and tobereleased in ('Y','y')  and    (atom_name like '% <_> <_>' or     atom_name like '% <__> <_>' or     atom_name like '% <_> <__>' or     atom_name like '% <__> <__>')|MTH/MM with double brackets|N|MTH/MM and MTH/TM atoms should never have double sets of brackets.  Cases identified probably result from MM atoms that are themselves ambiguous (this should be rare).|0|||
source specific integrities|select /*+ parallel(r) */ relationship_id from context_relationships r where source in (select current_name from source_version where source='MSH') and release_mode != '00' and parent_treenum='A0434168.A2367949'|Bad CMSH release_mode|N|For now, CMeSH atoms exist in a flat hierarchy without SIB relationships.  This check validates that the release_mode is set properly for these cases.  note, the parent_treenum is hardcoded and may change (A0434168.A2367949).|0||UPDATE context_relationships SET release_mode='00' WHERE release_mode != '00' and parent_treenum='A0434168.A2367949' and source in (select current_name from source_version where source='MSH')|
core table semantics|select /*+ parallel(s) */ sui from string_ui s where (string like '%' || chr(10) || '%' or string like '%' || chr(1) || '%' or string like '%' || chr(8) || '%')|Strings with junk characters|N|Strings should never contain newline or other junk characters.  This will wreak havoc with scripts like the one that assigns new LUI values.  To fix, identify the rows from <tt>string_ui</tt> and remove all corresponding data from <tt>classes</tt>, <tt>dead_classes</tt>, <tt>word_index</tt>, <tt>dead_word_index</tt>, <tt>normstr</tt>, <tt>dead_normstr</tt>, <tt>normwrd</tt>, and <tt>dead_normwrd</tt>.  Make sure you verify that the data you are removing can be replaced with strings without the newline.|0|||
core table semantics|select atom_id from classes where tobereleased in ('Y','y') and tty in ('MH') and source in (select source from sims_info where context_type is not null) and language='ENG' minus select /*+ PARALLEL(cr) */ atom_id_1 from context_relationships cr where tobereleased in ('Y','y') and source in (select current_name from source_version where source='MSH') and relationship_name='PAR'|Preferred atoms without contexts|N|The preferred atoms of every source with contexts should have at least one context.  We identify preferred atoms by looking in a particular list of termgroups.|0|||
other referential integrities|select concept_id_1 as concept_id, atom_id_1 from relationships where relationship_level !='C' and tobereleased in ('Y','y') minus select concept_id,atom_id from classes union select concept_id_2, atom_id_2 from relationships where relationship_level !='C' and tobereleased in ('Y','y') minus select concept_id, atom_id from classes|Non C rels concept_id,atom_id in sync|Y|With atom-level relationships, the (concept_id_1,atom_id_1) and (concept_id_2,atom_id_2) tuples should match the (concept_id,atom_id) tuples in the <tt>classes</tt> table.  If they do not, the most likely solution is to delete the offending rels (especially if the atom ids are in <tt>dead_atoms</tt>).|0|||
unique identifier (ui) integrity|select max(aui) from (select aui from classes union all select aui from dead_classes union all select aui from foreign_classes) having to_number(substr(max(aui),2)) > (select max_id from max_tab where table_name='AUI')|aui out of range|N|An <tt>aui</tt> found in classes,dead_classes, or foreign_classes must never be greater than the <tt>max_id</tt> for auis in the max_tab table.  This query returns the maximum <tt>aui</tt> that violates this condition.|0|||
core table semantics|select /*+ PARALLEL(wi) */ atom_id, word from word_index wi where lower(word)!=word and rownum<10|Uppercase words|N|Words in the <tt>word_index</tt> table should always be lowercased.  If this violation continues to pop up, figure out which code is inserting them in a case-sensitive fashion.  Fix the problem like this:<p><pre>update word_index set word=lower(word) where word!=lower(word);</pre></p>.|0||update word_index set word=lower(word) where word!=lower(word)|
core table semantics|select /*+ PARALLEL(a) */ distinct a.source,atom_id from context_relationships a, classes b where atom_id_2 = atom_id and a.tobereleased in ('Y','y') and b.tobereleased in ('N','n') and relationship_name='PAR'|Unreleasable parent in current source|N|Every atom that is the parent of another atom in some hierarchy must be releasable.|0|||
string unique identifier integrity|select distinct concept_id from classes where sui in (select sui from string_ui where string_pre like ' %') and tobereleased in ('Y','y')|leading spaces|Y|Strings should not have leading spaces.  If they do, it is an error in some input program that allows these to exist.  To fix the problem, make a worklist and force people to re-insert the atoms.  Or, if the string without the leading space is unique, just fix in string_ui and atoms, preserving the SUI values.|0|||
core table semantics|select /*+ PARALLEL(r) */ concept_id_1 as concept_id, relationship_id from relationships r where relationship_level='S' and source='NLM02' and relationship_attribute in ('ingredient_of','constitues','has_ingredient','consists_of') and tobereleased in ('N','n') and atom_id_1 in (select atom_id from classes where tobereleased in ('Y','y')) and atom_id_2 in (select atom_id from classes where tobereleased in ('Y','y'))|Unreleasable RxNorm relationships|Y|It is possible for releasable RxNorm ingredient or component relationships to become unreleasable when they really are still unreleasable.  One such case is if the source of a particular ingredient atom is updated and there is no safe-replacement atom to for the ingredient atom.  In this situation, the obsolete source ingredient atom will be made unreleasable as will its relationships.  Later, the RxNorm relationship will be re-mapped to a releasable atom but it will already have been made unreleasable, and we will have to go back and make it releasable again.

If this problem is encountered, identify the relevant relationship ids and run a process (using <tt>MEME_BATCH_ACTIONS.macro_action</tt>) to convert them back to <tt>tobereleased='Y'</tt>.

In the future, we may find a better way of dealing with this issue.|0|||
new src integrities|select a.source from source_version a, source_rank b where current_name=b.source and b.source=b.normalized_source minus select atom_name from atoms a, classes b where a.atom_id=b.atom_id and b.source='SRC' and b.termgroup='SRC/RAB' and tobereleased in ('Y','y') and concept_id in (select concept_id from classes where source='SRC' and termgroup='SRC/SSN' and tobereleased in ('Y','y') group by concept_id having count(distinct sui)=1)|Source without exactly one SRC/SSN|N|Every <i>root</i> SRC concept should have exactly one <i>source short name</i> (SRC/SSN).  For existing sources, look on the Knowledge Sources Server to get the current name; for new sources, get approval from Carolyn Tilley, through Bill Hole.  If a <i>root</i> SRC concept has multiple SRC/SSN atoms, delete one of them.|0|||
new src integrities|select a.source from source_version a, source_rank b where current_name=b.source and b.source=b.normalized_source minus select atom_name from atoms a, classes b where a.atom_id=b.atom_id and b.source='SRC' and b.termgroup='SRC/RAB' and tobereleased in ('Y','y') and concept_id in (select concept_id from classes where source='SRC' and termgroup='SRC/RPT' and tobereleased in ('Y','y') group by concept_id having count(distinct sui)=1)|Source without exactly one SRC/RPT|N|Every source must have exactly one releasable SRC/RPT atom.  This query finds sources where this condition is violated.  There are two possible problems, and two corresponding fixes:<ol><li>If there are no SRC/RPT atoms, then add one</li><li>If there are multiple SRC/RPT atoms, remove duplicates</li></ol>|0|||
new src integrities|select a.source from source_version a, source_rank b where current_name=b.source and b.source=b.normalized_source minus select atom_name from atoms a, classes b where a.atom_id=b.atom_id and b.source='SRC' and b.termgroup='SRC/RAB' and tobereleased in ('Y','y') and concept_id in (select concept_id from classes where source='SRC' and termgroup='SRC/RAB' and tobereleased in ('Y','y') group by concept_id having count(distinct sui)=1)|Source without exactly one SRC/RAB|N|Every source must have exactly one releasable SRC/RAB atom.  This query finds sources where this condition is violated.  There are two possible problems, and two corresponding fixes:<ol><li>If there are no SRC/RAB atoms, then add one</li><li>If there are multiple SRC/RAB atoms, remove duplicates</li></ol>|0|||
other referential integrities|select /*+ PARALLEL(cr) */ relationship_id from context_relationships cr where relationship_name NOT IN (select relationship_name from inverse_relationships)|Invalid relationship_name (CR)|N|Every <tt>relationship_name</tt> in the context_relationships table must have the same <tt>relationship_name</tt> in the inverse_relationships table.  This query returns <tt>relationship_id</tt>'s where a <tt>relationship_name</tt> from the context_relationships table is not found in the inverse_relationships table.|0|||
other referential integrities|select /*+ PARALLEL(a) */ attribute_id from attributes a where released NOT IN ('A','N')|Invalid released field (A)|N|Every atom must have a <tt>released</tt> field found in released_rank.  This query returns <tt>attribute_id</tt>'s from the attributes table where the <tt>released</tt> field is not in the table released_rank.|0|||
core table semantics|select concept_id, attribute_id from attributes where attribute_name='CONCEPT_NOTE' and (tobereleased NOT IN ('n','N') OR attribute_level !='C')|bad CONCEPT_NOTE attributes|Y|CONCEPT_NOTE attributes must be unreleasable and have a level of C.  This query returns <tt>concept_id</tt> and <tt>attribute_id</tt>s of offending cases.  To fix this problem, identify those rows and change either the offending <tt>tobereleased</tt> or <tt>attribute_level</tt> values using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select current_name from source_version where current_name in (select source from source_rank where source=normalized_source minus (select source from classes c where tobereleased in ('Y','y') union select source from foreign_classes fc where tobereleased in ('Y','y')))|Current sources without releasable atoms|N|All sources which are current should have releasable atoms.  This query returns a <tt>current_name</tt> for a source which does not have releasable atoms in the classes table.  If a source is deleted (e.g., MTHSCT) it will produce this violation.  In these cases, source_version should be updated so that previous_name=current_name and current_name is null.|5|NLM-MED, NCISEER and HLREL only have rels.  MBD and MED are for cocs.  These are all valid exceptions.||
unique identifier (ui) referential integrity|select atom_id from classes where tobereleased != 'N' and language='ENG' minus select normwrd_id from normwrd|Rows in classes minus normwrd|N|This may be off due to the addition/subtraction of atoms which have words that norm to the <i>empty string</i>.|25|Atoms with names where all of the words norm to the empty string.  Typically these are atoms whose words are all stop words.

2937942
2937943
2937944
2937945
2937946
2938034
2944148
2944149
2944150
2944151
11934006
12409813
12409815
12409817
12409819
12448386
12448388
12448390
12448392
12448394
39081708 - %
39081712 - %
39081713 - %
39081735 - %
39081736 - %
||
unique identifier (ui) referential integrity|select eng_atom_id from foreign_classes where tobereleased in ('Y','y') minus select atom_id from classes|Rows in foreign_classes minus classes|N|Every row in <tt>foreign_classes</tt> should have an <tt>eng_atom_id</tt> that can be found in the <tt>classes</tt> table.  If there are violations, it means that either the atoms were removed from classes (look in <tt>dead_classes</tt>) or bad rows were inserted into foreign classes.  The best approach is to probably delete the rows from foreign classes and reload those foreign atoms.|0|||
core table semantics|select /*+ PARALLEL(r) */ concept_id_1 as concept_id from relationships r where status='N' and relationship_level='S'	|Illegal S level relationship (status=N)|Y|Source asserted relationships must have a status of R or U.  This check returns <tt>concept_id</tt>s affected by this condition.  To fix this problem, first identify why it happened by finding the action that changed the status to N, and then change the status back to R using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
other referential integrities|select /*+ PARALLEL(r) */ concept_id_1 as concept_id, relationship_id, source relationship_id from relationships r where relationship_level='P' and source NOT IN (select source from source_rank)|P level relationships with invalid source|Y|Every P level relationship in the relationships table must have a <tt>source</tt> found in the source_rank table.  This querey returns <tt>concept_id</tt> and <tt>relationship_id</tt>s that violate this condition.|0|||
other referential integrities|select /*+ PARALLEL(c) */ atom_id from classes c where released NOT IN (select released from released_rank)|Invalid released field (C)|N|Every atom must have a <tt>released</tt> field found in released_rank.  This query returns <tt>atom_id</tt>'s from the classes table where the <tt>released</tt> field is not in the table released_rank.|0|||
other referential integrities|select /*+ PARALLEL(r) */ relationship_id,released from relationships r where released NOT IN (select released from released_rank)|Invalid released field (R)|N|Every atom must have a <tt>released</tt> field found in released_rank.  This query returns <tt>relationship_id</tt>'s from the relationships table where the <tt>released</tt> field is not in the table released_rank.|0|||
other referential integrities|select /*+ PARALLEL(cr) */ relationship_id from context_relationships cr where tobereleased NOT IN (select tobereleased from tobereleased_rank)|Invalid tobereleased field (CR)|N|Every atom must have a <tt>tobereleased</tt> field found in tobereleased_rank.  This query returns <tt>relationship_id</tt>'s from the context_relationships table where the <tt>tobereleased</tt> field is not in the table tobereleased_rank.|0|||
other referential integrities|select /*+ PARALLEL(a) */ attribute_id from attributes a where tobereleased NOT IN (select tobereleased from tobereleased_rank)|Invalid tobereleased field (A)|N|Every atom must have a <tt>tobereleased</tt> field found in tobereleased_rank.  This query returns <tt>attribute_id</tt>'s from the attributes table where the <tt>tobereleased</tt> field is not in the table tobereleased_rank.|0|||
other referential integrities|select /*+ PARALLEL(r) */ relationship_id from relationships r where suppressible NOT IN (select suppressible from suppressible_rank)|Invalid suppressible field (R)|N|Every atom must have a <tt>suppressible</tt> field found in suppressible_rank.  This query returns <tt>relationship_id</tt>'s from the relationships table where the <tt>suppressible</tt> field is not in the table suppressible_rank.|0|||
other referential integrities|select /*+ PARALLEL(a) */ attribute_id from attributes a where suppressible NOT IN (select suppressible from suppressible_rank)|Invalid suppressible field (A)|N|Every atom must have a <tt>suppressible</tt> field found in suppressible_rank.  This query returns <tt>attribute_id</tt>'s from the attributes table where the <tt>suppressible</tt> field is not in the table suppressible_rank.|0|||
other referential integrities|select /*+ PARALLEL(c) */ atom_id from classes a where status NOT IN (select status from level_status_rank where table_name='C')|Invalid status field (C)|N|Every atom in the classes table must have a status in the level_status_rank table.  This query returns <tt>atom_id<tt>'s that violate this condition.|0|||
new src integrities|select distinct a.concept_id from classes a, classes b, atoms c where a.source='SRC' and b.source='SRC' and b.termgroup='SRC/VAB' and a.code != concat('V-',c.atom_name) and b.atom_id=c.atom_id and a.concept_id=b.concept_id and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')|Code does not match SRC/VAB name|Y|Every SRC atom in a versioned SRC concept must have a code equal to V- appended to the <tt>SRC/VAB</tt> atom name from that same concept.  For example, in the <tt>MSH2002</tt> SRC concept, all SRC atoms should have a code equal to <tt>V-MSH2002</tt>.  Any violations of this check can be fixed by setting the invalid codes to the correct value.|0|||
core table semantics|select /*+ PARALLEL(c) */ concept_id,atom_id from classes c where tobereleased in ('Y','y') and termgroup not like concat('%/',tty)|Termgroup does not match tty|Y|The termgroup should end with the specified tty.  There is still code that does not correctly  manage this.  The fix is the following.<pre>update classes set tty=substr(termgroup,instr(termgroup,'/')+1) where nvl(tty,'null') != substr(termgroup,instr(termgroup,'/')+1); </pre>|0||update classes set tty=substr(termgroup,instr(termgroup,'/')+1) where nvl(tty,'null') != substr(termgroup,instr(termgroup,'/')+1)|
other referential integrities|select distinct a.key as col from meme_properties a where not exists (select 1 from meme_properties b where b.value like concat(concat('%,',a.key),'%') or b.value like concat(concat('%',a.key),',%') and b.key_qualifier='MRFILES') and key_qualifier='MRCOLS'|MRCOLS keys not in MRFILES keys|N|Data for MRCOLS and MRFILES is stored in the <tt>meme_properties</tt> table.  It is important that every column listed in the MRCOLS data participates as a column in at least one column list specified by the MRFILES data.  The inverse is also true but it is harder to implement.  Violations should be removed, or if correct, then MRFILEs data should be updated.|12|These are old column names.  ATX
CREL 
CUIS (from AMBIG files)
ISN
LRL
MG
RNK
SNA
SOC
SOUI
SUPRES
UN||
core table semantics|select concept_id,atom_id from foreign_classes where tobereleased in ('Y','y') and termgroup not like '%/'||tty|Termgroup (translation) does not match tty|Y|The termgroup should end with the specified tty.  There is still code that does not correctly  manage this.  The fix is the following.<pre>update foreign_classes set tty=substr(termgroup,instr(termgroup,'/')+1) where nvl(tty,'null') != substr(termgroup,instr(termgroup,'/')+1); </pre>|0||update foreign_classes set tty=substr(termgroup,instr(termgroup,'/')+1) where nvl(tty,'null') != substr(termgroup,instr(termgroup,'/')+1)|
core table semantics|select distinct current_name from source_version where previous_name in (select source from sims_info where insert_meta_version is not null and remove_meta_version is null) and current_name in (select distinct source from classes where last_releasE_rank = 0  and tobereleased in ('Y','y')  minus  select source from classes where last_release_rank != 0  and tobereleased in ('Y','y'))|Update sources with nonzero last release rank|N|Finds all update sources that only have zero last release rank values.  Typically this is indicative of a failure of the safe replacement algorithm to update across safe replacement facts.  To fix the problem, re-run last release rank inheritance section of the safe replacement algorithm.

To fix this problem, use $MEME_HOME/Patch/update_lrr.sql as a guide.|0|||
core table semantics|select a.rela as rela, a.rel as rel1, b.rel as rel2, a.source as source1, b.source as source2, a.ct as ct1, b.ct as ct2 from (select rel, rela, source, sum(ct) as ct from (select /*+ PARALLEL(r) */ relationship_name as rel, relationship_attribute as rela, source, count(*) ct from relationships r where (relationship_level = 'S' or source = 'NLM03') and relationship_attribute is not null and tobereleased in ('Y','y') group by relationship_name, relationship_attribute, source union all select /*+ PARALLEL(a) */ inverse_name, inverse_rel_attribute, source, count(*) ct from relationships a, inverse_relationships b, inverse_rel_attributes c where (relationship_level = 'S' or source = 'NLM03') and a.relationship_attribute is not null and tobereleased in ('Y','y') and a.relationship_name = b.relationship_name and a.relationship_attribute = c.relationship_attribute group by inverse_name, inverse_rel_attribute, source) group by rel, rela, source) a, (select rel, rela, source, sum(ct) as ct from (select relationship_name as rel, relationship_attribute as rela, 	  source, count(*) ct from relationships where (relationship_level = 'S' or source = 'NLM03') and relationship_attribute is not null and tobereleased in ('Y','y') group by relationship_name, relationship_attribute, source union all select inverse_name, inverse_rel_attribute, source, count(*) ct from relationships a, inverse_relationships b, inverse_rel_attributes c where (relationship_level = 'S' or source = 'NLM03') and a.relationship_attribute is not null and tobereleased in ('Y','y') and a.relationship_name = b.relationship_name and a.relationship_attribute = c.relationship_attribute group by inverse_name, inverse_rel_attribute, source) group by rel, rela, source) b where a.rela = b.rela and a.rel < b.rel and a.rel not in ('RT?') and b.rel not in ('RT?','SY') and (a.rel !='RT' or b.rel!='SFO/LFO') and a.rela not in ('mapped_to','mapped_from')|Conflicting relationships|N|This identifies cases where relationships have the same relationship attribute but conflicting relatonship names.  Generally, one set of these relationships will be erroneous.  To fix this problem, a content expert must determine which set of relationships is correct and fix the erroneous ones.

A case turned up where <tt>translation_of</tt> rels were RT for SRC concepts and SFO/LFO for foreign MDR.  The clause <tt>and (a.rel !='RT' or b.rel!='SFO/LFO')</tt> was added to account for this.

We ignore <tt>SY</tt> relationships because it is a way for a source to indicate that they believe the related atoms are the same.  In a sense this is not an express relationship in the same way a BT is.|2|precise_ingredient_of and has_precise_ingredient from RXNORM is acceptable for now pending future RXNORM changes.||
rxnorm semantics|select concept_id from classes where source='NLM02' and termgroup='NLM02/SCD' and tobereleased in ('Y','y') group by concept_id having count(distinct sui)>1|~ Normal form merges (SUI)|Y|All normal form atoms (NLM02/SCD) with the same case-sensitive string must be in the same concept.  The inverse of this is also true, meaning any concept containing a normal form atom should have only normal form atoms with the same case-sensitive string.  This check identifies concepts containing normal form atoms with different case-sensitive strings.|0|||
new src integrities|select stripped_source from source_rank sr, sims_info si, source_version sv where sr.source = sr.normalized_source  and si.source = sr.source  and context_type is not null and sr.source=current_name  minus select atom_name from atoms a, classes b   where a.atom_id=b.atom_id and b.source='SRC'   and b.termgroup='SRC/RAB' and tobereleased in ('Y','y')   and concept_id in (select concept_id from classes   where source='SRC' and termgroup='SRC/RHT'   and tobereleased in ('Y','y')   group by concept_id having count(distinct sui)=1)|Source with contexts and bad SRC/RHT|N|Every <i>root</i> SRC concept with contexts should have exactly one <tt>SRC/RHT</tt> atom in its SRC concept. This atom should be the tree-top for all contexts in every version of this source.   If the source has contexts (in <tt>context_relationships</tt>) but no SRC/RHT atom, the context should be rebuilt and connected to an SRC/RHT atom.  If there are multiple SRC/RHT atoms, one should be removed.|0|||
new src integrities|select distinct concept_id from classes where source='SRC' and tobereleased IN ('Y','y') MINUS select a.concept_id from attributes a, classes b where a.concept_id = b.concept_id and b.source='SRC' and attribute_value='Intellectual Product' and attribute_name||''='SEMANTIC_TYPE'|SRC concept no Intellectual Product STY|Y|Releasable SRC concepts must have an <tt>Intellectual Product</tt>  semantic type.  This query returns <tt>concept_id</tt>'s that violate this condition.  To fix the problem, remove any offending semantic types and insert valid ones.|0|||
new src integrities|select current_name from source_version a, source_rank b where b.source=current_name and b.source=b.normalized_source minus select atom_name from atoms a, classes b where a.atom_id=b.atom_id and b.source='SRC' and b.termgroup='SRC/VAB' and tobereleased in ('Y','y') and concept_id in (select concept_id from classes where source='SRC' and termgroup='SRC/VAB' and tobereleased in ('Y','y') group by concept_id having count(distinct sui)=1)|Source without exactly one SRC/VAB|N|Every source must have exactly one releasable SRC/VAB atom.  This query finds sources where this condition is violated.  There are two possible problems, and two corresponding fixes:<ol><li>If there are no SRC/VAB atoms, then add one</li><li>If there are multiple SRC/VAB atoms, remove duplicates</li></ol>|3|There are three exceptions.<ul>
<li>MTH has no versioned source</li>
<li>SRC has no versioned source</li>
<li>NLM-MED has no versioned source</li>
</ul>||
unique identifier (ui) integrity|select aui from classes    where tobereleased in ('Y','y')    and source = 'NLM02'    group by aui having count(*)>1|~ Non-unique AUI (NLM02)|N|No two releasable classes should have the same AUI.|0|||
unique identifier (ui) integrity|select /*+ parallel(a) */ atui from attributes a where tobereleased in ('Y','y')    and attribute_name !='SEMANTIC_TYPE' group by atui having count(distinct concept_id||attribute_name||hashcode||sg_id||sg_qualifier||source_atui)>1|Non-unique ATUI|N|No two releasable attributes should have the same ATUI (except for SEMANTIC_TYPE).|0|||
unique identifier (ui) integrity|select rui,parent_treenum from context_relationships    where tobereleased in ('Y','y')    group by rui,parent_treenum having count(*)>1|Non-unique RUI (CR)|N|No two releasable context relationships should have the same RUI.|0|||
core table semantics|select /*+ parallel(a) */ atom_id,string from string_ui a, classes b where a.sui=b.sui and (string like ' %'  or string like '% '  or string like '%'||chr(26) or string like '%  %') and tobereleased in ('Y','y')|Atom with leading/trailing junk|N|Releasable atoms should not have leading/trailing spaces or a trailing chr(26) or multiple spaces.|0|||
new src integrities|select /*+PARALLEL(r)*/ relationship_id from relationships  r   where relationship_name='version_of'  and source='SRC' minus  select /*+PARALLEL(r)*/ relationship_id from relationships  r where sg_type_1='CODE_TERMGROUP'         AND sg_type_2='CODE_TERMGROUP'        AND sg_qualifier_1='SRC/RPT'        AND sg_qualifier_2='SRC/VPT' and source='SRC'|Invalid type/qualifier for SRC version_of rels|N|SRC version_of rels should be sg_type_1='CODE_TERMGROUP'       AND sg_type_2='CODE_TERMGROUP' AND sg_qualifier_1='SRC/RPT'       AND sg_qualifier_2='SRC/VPT'|0|||
new src integrities|select /*+PARALLEL(r)*/ relationship_id from relationships   r  where relationship_name='translation_of'  and source='SRC' minus  select /*+PARALLEL(r)*/ relationship_id from relationships r where sg_type_1='CODE_TERMGROUP'         AND sg_type_2='CODE_TERMGROUP'        AND sg_qualifier_1='SRC/RPT'        AND sg_qualifier_2='SRC/RPT' and source='SRC'|Invalid type/qualifier for SRC translation_of rels|N|SRC translation_of rels should be sg_type_1='CODE_TERMGROUP' AND sg_type_2='CODE_TERMGROUP' AND sg_qualifier_1='SRC/RPT' AND sg_qualifier_2='SRC/RPT'|0|||
new src integrities|select concept_id from classes where source='SRC'  and termgroup='SRC/RAB' minus (select concept_id_1   from relationships a, classes b where relationship_name='RT'   and  concept_id_2 = b.concept_id and b.source='SRC' and   b.termgroup='SRC/RAB' and b.code='V-MTH' union select   concept_id_2 from relationships a, classes b where   relationship_name='RT' and concept_id_1 = b.concept_id   and b.source='SRC' and b.termgroup='SRC/RAB' and b.code='V-MTH')|Root SRC without MTH rel|Y|Every root SRC concept is required to have a relationship to the MTH SRC concept.  This check returns concept ids that violate this condition.  To fix the problem, insert this relationship. Use the following code as a guide:
<pre>
Drop table tbac;
Create table tbac as
Select distinct concept_id,code,atom_id from classes
where tobereleased in ('Y','Y') and source='SRC' and tty='RPT' and concept_id in
(select concept_id from classes where source='SRC' and termgroup='SRC/RAB' 
minus (select concept_id_1 from relationships a, classes b 
where relationship_name='RT' and concept_id_2 = b.concept_id 
and b.source='SRC' and b.termgroup='SRC/RAB' and b.code='V-MTH' 
union select concept_id_2 from relationships a, classes b 
where relationship_name='RT' and concept_id_1 = b.concept_id 
and b.source='SRC' and b.termgroup='SRC/RAB' and b.code='V-MTH')
);

drop table tbac2;
create table tbac2 as select
concept_id_1,concept_id_2,atom_id_1,atom_id_2,
                   relationship_name,relationship_attribute,
                   source, source_of_label,status,generated_status,
                   relationship_level,released,tobereleased,
                   relationship_id, suppressible,
                   sg_id_1, sg_type_1, sg_qualifier_1,
                   sg_id_2, sg_type_2, sg_qualifier_2,
                   source_rui, relationship_group
from relationships where 1=0;

insert into tbac2 
select 1565, concept_id, 8896299, atom_id,
'RT','','SRC','SRC','R','Y','S','N','Y',0,'N', 'V-MTH','CODE_TERMGROUP','SRC/RPT',
code,'CODE_TERMGROUP','SRC/RPT','',''
from tbac;

$MEME_HOME/bin/insert.pl -rels tbac2 $db $authority
</pre>|0|||
new src integrities|select concept_id from classes where source='SRC'  and termgroup='SRC/RPT' and substr(code,3) in  (select stripped_source from sims_info a, source_rank b  where a.source=b.source and language !='ENG')  minus (select concept_id_1  from relationships a, classes b where relationship_name='RT'  and relationship_attribute='has_translation' and  concept_id_2 = b.concept_id and b.source='SRC' and  b.termgroup='SRC/RPT' union select  concept_id_2 from relationships a, classes b where  relationship_name='RT' and relationship_attribute='translation_of'  and concept_id_1 = b.concept_id  and b.source='SRC' and b.termgroup='SRC/RPT')|Non-ENG root SRC without translation_of rel|Y|Every root SRC concept for a non-english source is required to have a <tt>translation_of</tt> relationship to its respective english language root SRC concept.  This check returns concept ids that violate this condition.  To fix the problem, insert the required relationship.  Use this code as a guide:
<pre>
Drop table tbac;
Create table tbac as
Select distinct concept_id,code,atom_id from classes
where tobereleased in ('Y','Y') and source='SRC' and tty='RPT' and concept_id in
(select concept_id from classes where source='SRC' 
and termgroup='SRC/RPT' and substr(code,3) 
in (select stripped_source from sims_info a, source_rank b where a.source=b.source and language !='ENG') 
minus (select concept_id_1 from relationships a, classes b where relationship_name='RT' 
and relationship_attribute='has_translation' and concept_id_2 = b.concept_id 
and b.source='SRC' and b.termgroup='SRC/RPT' union select concept_id_2 
from relationships a, classes b where relationship_name='RT' 
and relationship_attribute='translation_of' and concept_id_1 = b.concept_id 
and b.source='SRC' and b.termgroup='SRC/RPT')
);

drop table tbac2;
create table tbac2 as select
concept_id_1,concept_id_2,atom_id_1,atom_id_2,
                   relationship_name,relationship_attribute,
                   source, source_of_label,status,generated_status,
                   relationship_level,released,tobereleased,
                   relationship_id, suppressible,
                   sg_id_1, sg_type_1, sg_qualifier_1,
                   sg_id_2, sg_type_2, sg_qualifier_2,
                   source_rui, relationship_group
from relationships where 1=0;

-- 6598515 is the concept id for V-MSH, 8312708 is the RPT atom id.
insert into tbac2 
select 6598515, concept_id, 8312708, atom_id,
'RT','translation_of','SRC','SRC','R','Y','S','N','Y',0,'N', 'V-MSH','CODE_TERMGROUP','SRC/RPT',
code,'CODE_TERMGROUP','SRC/RPT','',''
from tbac;

$MEME_HOME/bin/insert.pl -rels tbac2 $db $authority
</pre>|0|||
core table semantics|select /*+ parallel(a) */ sui from string_ui a where string != convert(convert(string,'AL24UTFFSS','UTF8'),'UTF8','AL24UTFFSS')|Non-UTF8 string_ui rows|N|All strings should contain only valid UTF-8 characters.  This check finds violations in string_ui.|0|||
core table semantics|select /*+ parallel(a) */ attribute_id,concept_id from attributes a where tobereleased in ('Y','y') and attribute_value not like '<>Long_Attribute<>:%' and attribute_value != convert(convert(attribute_value,'AL24UTFFSS','UTF8'),'UTF8','AL24UTFFSS')|Non-UTF8 attributes rows|N|All strings should contain only valid UTF-8 characters.  This check finds violations in attributes.|0|||
core table semantics|select /*+PARALLEL(st)*/ * from stringtab st where length(text_value) != text_total  and text_total <= 1784|Incorrect text_total in stringtab|N|For entries in stringtab of length <= 1784, the length of the text_value should be accurately recorded as text_total.  This check returns cases where text_total is incorrect.|0||update /*+PARALLEL(st)*/ stringtab st set text_total=length(text_value) where length(text_value) != text_total  and text_total <= 1784|
rxnorm semantics|select distinct a.concept_id from classes a, classes b  where a.concept_id=b.concept_id  and a.source='NLM02'  and b.source=(select current_name from source_version where source='HL7') and b.tty='DF' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')|RxNorm and HL7 merges|Y|A concept should not contain both a releasable NLM02 atom and a releasable current-version HL7 atom.|0|||
new src integrities|select relationship_id, source from relationships    where relationship_name in ('version_of','has_version') and source != 'SRC'|Non-SRC version_of rels|N|All version_of relationships should be owned by SRC.|0|||
core table semantics|select /*+ parallel(c) */ atom_id from classes c where language is null|Null language in classes|N|Every atom in classes should have a non-null language field.|0|||
new src integrities|select atom_id,attribute_name,attribute_value,source from attributes  where attribute_name in ('TOVSAB','FROMVSAB')  and source not in (select source from source_rank)|TOVSAB, FROMVSAB attributes with invalid source|N|TOVSAB and FROMVSAB attributes should have a source in source_rank.|0|||
source specific integrities|select concept_id,source_cui  from classes where tobereleased in ('Y','y') and source like 'MSH%'  and language != 'ENG'  and source_cui like 'M%'  and source_cui in (select source_cui from classes where language='ENG' and tobereleased in ('Y','y')) minus  select concept_id,source_cui  from classes a, source_version b  where a.source=current_name  and b.source='MSH'|~~ MSH foreign not in same concept as matching MUI|N|MSH foreign atoms must be in the same concept as MSH atoms with matching MUI (source_cui).  Make a table of possible matches by doing the following: <pre>create table tjfw as select concept_id,source_cui from classes 
  where source like 'MSH%' and language != 'ENG' and source_cui like 'M%' and source_cui in 
    (select source_cui from classes where language='ENG' and tobereleased in ('Y','y')) minus
    select concept_id,source_cui from classes a, source_version b where a.source=current_name and b.source='MSH';

  create table tjfw2 as select distinct a.concept_id as concept_id_1, a.source_cui, b.concept_Id as concept_id_2  
  from tjfw a, classes b
  where a.source_cui=b.source_cui and b.language='ENG'
  and b.source='MSH2006_2005_08_01' and tobereleased in ('Y','y');</pre>|0|||
source specific integrities|select distinct a.source,a.concept_id,a.code  from classes a, classes b  where a.source in  (select current_name from source_version where source like 'MDR___')  and b.source in  (select current_name from source_version where source='MDR')  and a.code= b.code  and a.concept_id != b.concept_id   and b.source_cui in (select source_cui from classes where source like 'MDR%' and language='ENG' group by source_cui having count(distinct concept_id)>1)|~~ MDR foreign split codes|N|MDR foreign sources should not have split codes with respect to MDR.|0|||
new src integrities|select distinct concept_id from classes where source='SRC' and language !='ENG'|SRC atoms must have ENG language|N|SRC atoms must have their language set as ENG.|0|||
other referential integrities|select concept_id, atom_id from attributes where attribute_level !='C' and tobereleased in ('Y','y') minus select concept_id,atom_id from classes|Non C atts concept_id,atom_id in sync|Y|With atom-level attributes, the (concept_id,atom_id) and tuples should match the (concept_id,atom_id) tuples in the <tt>classes</tt> table.  If they do not, the most likely solution is to delete the offending rels (especially if the atom ids are in <tt>dead_atoms</tt>).|0|||
unique identifier (ui) integrity|select string_id from (select string_id from stringtab union all select string_id from dead_stringtab) where string_id > (select row_sequence from stringtab where string_id=-1)|string_id out of range ({dead_,}stringtab)|N|A <tt>string_id</tt> found in stringtab or dead_stringtab must never be greater than the <tt>row_sequence</tt> for a string_id value of -1 in the stringtab table.  This query returns <tt>string_id</tt>'s that violate this condition.|0|||
string unique identifier integrity|select sui from string_ui group by sui having count(*)>1|Non-unique SUI in string_ui|N|Every <tt>SUI</tt> in the string_ui table must be distinct.  This query returns <tt>SUI</tt>'s that have a redundant value.|0|||
string unique identifier integrity|select lui from string_ui group by lui having count(distinct norm_string)>1|LUI-norm_string mismatch|N|Every <tt>LUI</tt> must have a distinct <tt>norm_string</tt> in the string_ui table.  This query returns <tt>LUI</tt>'s that violate this condition.|0|||
string unique identifier integrity|select lui from string_ui where lui in (select lui from string_ui where lowercase_string_pre = 'in' and language='ENG') and norm_string IS NOT NULL|Rows w/ null LUI & non-null norm_string|N|The <tt>LUI</tt> equal to the null LUI must have an empty (NULL) <tt>norm_string</tt> value in the table string_ui.  This query returns this same <tt>LUI</tt>, when a non NULL value in the <tt>norm_sting</tt> field exists.|0|||
core table semantics|select concept_id, attribute_id from attributes where attribute_name='ATOM_NOTE' and (tobereleased NOT IN ('n','N') OR attribute_level !='S')|bad ATOM_NOTE attributes|Y|ATOM_NOTE attributes must be unreleaseable and have a level of S.  The <tt>attribute_id</tt>s of offending rows are returned by this check.  To fix the problem, identify the rows and fix the offending <tt>tobereleased</tt> or <tt>attribute_level</tt> fields using <tt>MEME_BATCH_ACTIONS.macro_action</tt> to fix the problem.|0|||
core table semantics|select concept_id, attribute_id from attributes where attribute_name='SYNTACTIC_CATEGORY' and (tobereleased NOT IN ('n','N') OR attribute_level !='C')|bad SYNTACTIC_CATEGORY attributes|Y|SYNTACTIC_CATEGORY attributes must be unreleasable and have an attribute level of C.  This query returns <tt>concept_id</tt> and <tt>attribute_id</tt>s of offending cases.  To fix this problem, identify those rows and change either the offending <tt>tobereleased</tt> or <tt>attribute_level</tt> values using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select concept_id, attribute_id from attributes where attribute_name='NON_HUMAN' and (tobereleased NOT IN ('y','Y') OR attribute_level !='C')|bad NON_HUMAN attributes|Y|NON_HUMAN attributes must be releasable and have a level of C.  This query returns <tt>concept_id</tt> and  <tt>attribute_id</tt>s of offending cases.  To fix this problem, identify those rows and change either the offending <tt>tobereleased</tt> or <tt>attribute_level</tt> values using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select concept_id, attribute_id from attributes where attribute_name='DEFINITION' and attribute_level !='S'|bad DEFINITION attributes|Y|DEFINITION attributes must have a level of S.  This check returns <tt>concept_id</tt> and <tt>attribute_id</tt>s of offending cases.  To fix violations, identify rows with incorrect <tt>attribute_level</tt> values and fix them using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select /*+ PARALLEL(c) */ concept_id from classes c where tobereleased IN ('y','Y') group by concept_id having count(distinct status)>1|~ Mixed status concepts|Y|This will not be zero during the editing cycle but must be zero for a release.|0|||
core table semantics|select string from   (select substr(atom_name,0,length(atom_name)-4) as string   from classes a,atoms b where a.atom_id=b.atom_id   and a.source='MTH' and a.tty in ('MM','TM')   and b.atom_name like '% <_>'  UNION ALL   select substr(atom_name,0,length(atom_name)-5)   from classes a,atoms b where a.atom_id=b.atom_id   and a.source='MTH' and tty in ('MM','TM')   and b.atom_name like '% <__>') MINUS select string from string_ui|MTH/MM atoms without stripped strings|N|MTH/MM atoms are created to disambiguate ambiguous strings.  When they are created, the base string (the string without the <#>) is derived from the underlying ambiguous string.  As a result, all MTH/MM atoms should have stripped string values which appear (in a case-sensitive way) in <tt>string_ui</tt>.  This check reports the stripped string values for MTH/MM atoms which do not have such corresponding rows. <p>Violations of this check should be exceedingly rare and indicate a serious problem with the code that generates these atoms.

Running "Remove MM/TMs." using <a href="/cgi-bin/mid_maintenance.cgi">MID Maintenance</a> should solve this problem (if they are TM atoms).  If they are MTH/MM atoms, you will probably have to remove them manually.|8|These are reoccurring issues and not releasable.||
core table semantics|select /*+ PARALLEL(a) */ distinct a.source from classes a,source_version b where a.source=b.previous_name and a.tobereleased IN ('y','Y')|obsolete sources with releasable atoms|N|A source that is not current should have only unreleasable atoms.  This query finds sources which are obsolete and yet have atoms that are releasable.|0|||
other referential integrities|select concept_id, atom_id, source from classes where tobereleased in ('Y','y') and source NOT IN (select current_name from source_version)|Rows in classes with invalid sources|Y|Every releasable atom must have a <tt>source</tt> listed as current in <tt>source_version</tt>.  This query returns <tt>concept_id</tt>'s where this condition is violated.|0|||
other referential integrities|select /*+ parallel(a) */ attribute_id,source from attributes a where attribute_level='S' and source NOT IN (select source from source_rank) and source not like 'E-%' and tobereleased in ('Y','y')|S level attributes with invalid source|N|Every S level attribute must have its <tt>source</tt> field present and ranked in the source_rank table.  This query returns <tt>attribute_id</tt>'s where this condition is violated.|0|||
core table semantics|select /*+ parallel(a) */ string_id from stringtab a where text_Value != convert(convert(text_value,'AL24UTFFSS','UTF8'),'UTF8','AL24UTFFSS')|Non-UTF8 stringtab rows|N|All strings should contain only valid UTF-8 characters.  This check finds violations in stringtab.|0|||
rxnorm semantics|select atom_id from classes where source='NLM02' and termgroup='NLM02/SCDF' and tobereleased in ('Y','y') minus (select atom_id_1 from relationships a, classes b where a.source='NLM02' and relationship_attribute='isa' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SCD' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|SCDF without a normal form|Y|Every semantic clinical drug and form must be connected to a normal form.  This check returns cases which are not.  To fix, click <a href="/cgi-lti-oracle/rxnorm_maintenance.cgi">here</a> and select "Disable Unused Atoms".|0|||
core table semantics|select concept_id, attribute_id from attributes where attribute_name='LEXICAL_TAG' and attribute_value='TRD' and source not in (select source from source_rank where stripped_source='MSH' minus select current_name from source_version where source='MSH') and (tobereleased NOT IN ('y','Y') OR attribute_level !='S')|bad LEXICAL_TAG (TRD)  attributes|Y|TRD LEXICAL_TAG attributes (not from old versions of MSH) must be releasable and have a level of S.  This query returns <tt>concept_id</tt> and <tt>attribute_id</tt>s of offending cases.  To fix this problem, identify those rows and change either the offending <tt>tobereleased</tt> or <tt>attribute_level</tt> values using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0||DECLARE x number;  BEGIN  MEME_UTILITY.drop_it('table', 'tjfw_$$');  EXECUTE IMMEDIATE 'create table tjfw_$$ as select attribute_id as row_id from attributes where attribute_name=''LEXICAL_TAG'' and attribute_value=''TRD'' and tobereleased NOT IN (''y'',''Y'') and source not in (select source from source_rank where stripped_source=''MSH'' minus select current_name from source_version where source=''MSH'')';  x:=MEME_BATCH_ACTIONS.macro_action(  action=>'T', id_type=>'A', authority=>'L-JFW',  table_name=>'tjfw_$$', work_id=>0, status=>'R',  new_value=>'Y');  MEME_UTILITY.drop_it('table', 'tjfw_$$');  END;|
rxnorm semantics|select atom_id from attributes where attribute_name='RX_NORM_STATUS' group by atom_id having count(distinct attribute_value)>1|Too many RX_NORM_STATUS values|N|An atom should never have more than one RX_NORM_STATUS value. This check identifies <tt>atom_id</tt>s with more than one distinct RX_NORM_STATUS value.|0|||
rxnorm semantics|SELECT atom_id FROM classes WHERE source = 'NLM02' AND aui IN (SELECT aui FROM atoms_ui WHERE code IS NOT NULL)|RXNORM atoms with non-null code in atoms_ui|N|"When computing AUIs for RXNORM (NLM02) atoms we use a null code value.  This check finds all cases of NLM02 atoms whose AUI was computed using a non-null code."|0|||
string unique identifier integrity|SELECT concept_id,atom_id,sui FROM classes WHERE nvl(language,'ENG')='ENG' AND sui in (SELECT sui FROM string_ui WHERE language!='ENG')|ENG strings with foreign language SUIs|N|English language atoms must have english language SUIs.  This check finds cases of english atoms with foreign language suis.|0|||
new src integrities|select normalized_source from source_rank minus select source from sims_info|Missing sims_info data|Y|Every source in <tt>source_rank</tt> should be represented also in <tt>sims_info</tt>. This check returns cases of sources inserted into <tt>source_rank</tt> but left out of <tt>sims_info</tt>.  Make sure the relevant data is added to <tt>sims_info</tt>.|0|||
rxnorm semantics|select atom_id_2, concept_id_2 from relationships a, classes b where a.source='NLM02' and relationship_attribute='constitutes' and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup in ('NLM02/SCD','NLM02/SBD') and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y') group by atom_id_2,concept_id_2 having count(*) > 1|Component with too many normal forms|Y|Every norm form component must be connected to exactly one norm form.  This check returns cases which are connected to more than one.|0|||
rxnorm semantics|select atom_id, concept_id from classes where source='NLM02' and termgroup='NLM02/SCDC' and tobereleased in ('Y','y') minus (select atom_id_2, concept_id_2 from relationships a, classes b where a.source='NLM02' and relationship_attribute='constitutes' and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup in ('NLM02/SCD','NLM02/SBD') and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|Component without normal form|Y|Every norm form component must be connected to a norm form.  This check returns cases which are not.  To fix, click <a href="/cgi-lti-oracle/rxnorm_maintenance.cgi">here</a> and select "Disable Unused Atoms".|0|||
rxnorm semantics|select atom_id,concept_id from classes where source='NLM02' and termgroup in ('NLM02/SCDC') and tobereleased in ('Y','y') minus (select atom_id_1,concept_id_1 from relationships a, classes b where a.source='NLM02' and relationship_attribute='ingredient_of' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/IN' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|Component without ingredient|Y|Every component must be connected to an ingredient atom. This check returns cases which are not.|0|||
rxnorm semantics|select atom_id_1 as atom_id ,concept_id_1 as concept_id from relationships a, classes b where a.source='NLM02' and relationship_attribute='ingredient_of' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/IN' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and atom_id_1 in (select atom_id from classes where source='NLM02' and termgroup='NLM02/SCDC' and tobereleased  in ('Y','y')) group by atom_id_1,concept_id_1 having count(*) >1|Component with too many ingredients|Y|Every component must be connected to exactly one ingredient atom. This check returns cases which are connected to more than one. To fix this problem, run the auto fix for "Duplicate RxNorm relationships."|0|||
rxnorm semantics|select atom_id,concept_id from classes where source='NLM02' and termgroup in ('NLM02/SBD') and tobereleased in ('Y','y') minus (select atom_id_1,concept_id_1 from relationships a, classes b where a.source='NLM02' and relationship_attribute='ingredient_of' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/BN' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|Branded normal form without ingredient|Y|Every branded normal form atom must be connected to an ingredient atom.  These check returns cases which are not.|0|||
rxnorm semantics|select atom_id_1 as atom_id ,concept_id_1 as concept_id from relationships a, classes b where a.source='NLM02' and relationship_attribute='ingredient_of' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/BN' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y') group by atom_id_1,concept_id_1 having count(*) >1|Branded normal form with too many ingredients|Y|Every branded normal form atom must be connected to exactly one ingredient.  This check returns cases which are connected to more than one.|0|||
unique identifier (ui) integrity|select sui,stripped_source,tty,code,source_aui,source_cui,source_dui from atoms_ui group by sui,stripped_source,tty,code,source_aui,source_cui,source_dui having count(*)>1|Duplicate AUI values|N|Each set of values from <tt>atoms_ui</tt> should map to a unique AUI value.  This check finds cases that do not.  A guide for fixing this problem is below.

<pre>drop table t_aui_map;
create table t_aui_map as
  select min(a.aui) as new_aui, b.aui as old_aui
  from atoms_ui a, atoms_ui b
  where a.sui = b.sui
  and a.aui != b.aui
  and a.stripped_source = b.stripped_source
  and a.tty = b.tty
  and a.code||a.source_aui||'|'||a.source_cui||a.source_dui = b.code||b.source_aui ||'|'||b.source_cui||b.source_dui
  group by b.aui;

delete from atoms_ui where aui in (select old_aui from t_aui_map);
create index x_tauimap on t_aui_map(old_aui) compute statistics parallel;

update classes a set aui =
(select new_aui from t_aui_map b where aui=old_aui)
where aui in (select old_aui from t_aui_map);

update foreign_classes a set aui =
(select new_aui from t_aui_map b where aui=old_aui)
where aui in (select old_aui from t_aui_map);

update dead_classes a set aui =
(select new_aui from t_aui_map b where aui=old_aui)
where aui in (select old_aui from t_aui_map);</pre>|0|||
rxnorm semantics|select atom_id, concept_id from classes where source='NLM02' and termgroup='NLM02/SBD' and tobereleased in ('Y','y') minus (select atom_id_1,concept_id_1 from relationships a, classes b where a.source='NLM02' and relationship_name='SFO/LFO' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SY')|Branded normal form without an SY|Y|Every branded normal form must be connected to a synonym.  This check returns cases which are not. The following code can be used as a guide to fix this problem:
<pre>
ALTER SESSION set sort_area_size=200000000;
ALTER SESSION set hash_area_size=200000000;

#
# Find cases
#
drop table tbacx;
create table tbacx as
select * from classes where source='NLM02' and tty='SBD'
and tobereleased in ('Y','y') and atom_id not in
(select atom_id_1 from relationships a, classes b
where a.source='NLM02' and relationship_name='SFO/LFO'
and atom_id_2=b.atom_id and b.source='NLM02'
and b.tty='SY');

#
# Build multiple component cases
#
truncate table source_classes_atoms;
insert into source_classes_atoms
select 'R', a.atom_id, 'NLM02','NLM02/SY','SY',0,'','','','','','Y','R',
'N','n', bn.atom_name || ' ' || df.atom_name, 0, a.concept_id,
0,0,'','','N','','','','','ENG',''
from tbacx a, atoms bn, atoms df, relationships b, relationships c
where a.atom_id = b.atom_id_1
  and a.atom_id = c.atom_id_1
  and b.source='NLM02' and b.relationship_attribute='dose_form_of'
  and b.atom_id_2=df.atom_id
  and c.source='NLM02' and c.relationship_attribute='ingredient_of'
  and c.atom_id_2=bn.atom_id
  and a.atom_id in
 (select atom_id_1 from relationships r
  where r.atom_id_1=a.atom_id
  and relationship_attribute='constitutes'
  and source='NLM02'
  group by atom_id_1 having count(*)>1);

#
# Build single component cases
#
truncate table source_classes_atoms;
insert into source_classes_atoms
select 'R', a.atom_id, 'NLM02','NLM02/SY','SY',0,'','','','','','Y','R',
'N','Y', bn.atom_name || ' ' || str || ' ' || df.atom_name, 
0, a.concept_id,0,0,'','','N','','','','','ENG',''
from tbacx a, atoms bn, atoms df, relationships b, relationships c,
 (select a.atom_id, substr(scdca.atom_name,length(ina.atom_name)+2) str
  from tbacx a, classes scdc, classes ing, atoms scdca, atoms ina, 
	relationships sbdscdc, relationships scdcin
  where a.atom_id = sbdscdc.atom_id_1 and scdc.atom_id = scdcin.atom_id_1
    and sbdscdc.relationship_attribute = 'constitutes'
    and scdcin.relationship_attribute = 'ingredient_of'
    and sbdscdc.atom_id_2 = scdc.atom_id and scdcin.atom_id_2 = ing.atom_id
    and scdc.atom_id = scdca.atom_id and ing.atom_id = ina.atom_id ) str  
where a.atom_id = b.atom_id_1
  and a.atom_id = c.atom_id_1
  and b.source='NLM02' and b.relationship_attribute='dose_form_of'
  and b.atom_id_2=df.atom_id
  and c.source='NLM02' and c.relationship_attribute='ingredient_of'
  and c.atom_id_2=bn.atom_id
  and str.atom_id = a.atom_id
  and a.atom_id in
 (select atom_id_1 from relationships r
  where r.atom_id_1=a.atom_id
  and relationship_attribute='constitutes'
  and source='NLM02'
  group by atom_id_1 having count(*)=1);

#
# source processing: do in unix
# 
/site/umls/oracle/scripts/dump_table.pl -u $mu -d $db -q \
 "select distinct atom_name from source_classes_atoms" >! x
perl -pe 's/^/|||||||/; s/$/|||||ENG|/' x >! classes_atoms.src
classes_to_strings.csh . ENG
load_src.csh $db strings.src
/bin/rm -r -f x

  exec meme_source_processing.assign_string_uis('MTH',0);
  exec meme_source_processing.assign_meme_ids('C','MTH',0);
  exec meme_source_processing.core_table_insert('C','MTH',0);

#
# Build relationships between SBD/SY
# 
truncate table source_relationships;
insert into source_relationships
select 'R', 0, 0, a.atom_id, b.atom_id, a.concept_id, b.concept_id,
'','','','','','','','','','','NLM02','NLM02','S','SFO/LFO','','Y',
'R','N','Y','','N','','',''
from tbacx a, source_classes_atoms b
where a.atom_id=b.source_atom_id;

update source_relationships set tobereleased='n'
where atom_id_2 in (select atom_id from classes where tobereleased='n');

  exec meme_source_processing.assign_meme_ids('R','MTH',0);
  exec meme_source_processing.core_table_insert('R','MTH',0);
</pre>|0|||
unique identifier (ui) integrity|select /*+ parallel(r)*/ rui from relationships r where tobereleased in ('Y','y')    group by rui having count(distinct concept_id_1||concept_id_2||atom_id_1||atom_id_2||sg_id_1||sg_id_2||sg_qualifier_1||sg_qualifier_2||relationship_name||relationship_attribute||relationship_group)>1|Non-unique RUI (R)|N|No two releasable relationships should have the same RUI.|0|||
core table semantics|select termgroup from termgroup_rank where termgroup not like concat('%/',tty)|Termgroup (termgroup_rank) does not match tty|Y|The termgroup should end with the specified tty.  There is still code that does not correctly  manage this.  The fix is the following.<pre>update termgroup_rank set tty=substr(termgroup,instr(termgroup,'/')+1) where nvl(tty,'null') != substr(termgroup,instr(termgroup,'/')+1); </pre>|0||update termgroup_rank set tty=substr(termgroup,instr(termgroup,'/')+1) where nvl(tty,'null') != substr(termgroup,instr(termgroup,'/')+1)|
unique identifier (ui) integrity|select aui, sui, c.stripped_source, code, tty   from foreign_classes a, source_rank b, source_rank c  where a.source = b.source and b.normalized_source = c.source    and tobereleased in ('Y','y')  minus  select aui, sui, stripped_source, code, tty   from atoms_ui|Bad AUI (foreign_classes - atoms_ui)|N|This check finds cases of atoms that have been assigned incorrect AUIs.  To fix this problem, set the AUIs in foreign_classes to null and run MEME_SOURCE_PROCESSING.assign_auis.|0|||
unique identifier (ui) referential integrity|select to_number(substr(attribute_value,20)) as string_id from attributes where attribute_value like '<>Long_Attribute<>:%' minus select string_id from stringtab|Rows in attributes minus stringtab|N|This query retuns <tt>string_id</tt>'s from the attributes table, having been extracted from the <tt>attribute_value</tt> of <tt>Long_Attributes</tt>, that do not match any <tt>string_id</tt>'s in the stringtab table.|0|||
unique identifier (ui) referential integrity|select atom_id from classes where tobereleased != 'N' and language='ENG' minus select normstr_id from normstr|Rows in classes minus normstr|N|This query retuns releasable <tt>atom_id</tt>'s from the classes table that do not match any <tt>normstr_id</tt>'s in the normstr table. (Note: atom_id's are equal to normstr_id's).|0|||
unique identifier (ui) referential integrity|select normstr_id from normstr minus select atom_id from classes|Rows in normstr minus classes|N|This query retuns <tt>normstr_id</tt>'s from the normstr table that do not match any <tt>atom_id</tt>'s in the classes table. (Note: normstr_id's are equivalent in value to atom_id's).|0|||
unique identifier (ui) referential integrity|select string_id from stringtab where string_id!=-1 minus select to_number(substr(attribute_value,20)) as string_id from attributes where attribute_value like '<>Long_Attribute<>:%'|Rows in stringtab minus attributes|N|This query retuns <tt>string_id</tt>'s from the stringtab table that do not match any <tt>string_id</tt>'s in the attributes table, having been extracted from the <tt>attribute_value</tt> of <tt>Long_Attribute</tt>.|0|||
unique identifier (ui) referential integrity|select atom_id from attributes where attribute_level='S' minus select atom_id from classes|S level attributes minus classes|N|This query retuns S level <tt>atom_id</tt>'s from the attributes table that do not match any <tt>atom_id</tt>'s in the classes table.|0|||
string unique identifier integrity|select string,language from string_ui group by string,language having count(*)>1|Non-unique string,language in string_ui|N|Every <tt>string</tt> must be distinct in the sting_ui table.  This query returns redundant <tt>string</tt>s.|0|||
string unique identifier integrity|select sui,language from foreign_classes minus select sui,language from string_ui|Rows in foreign_classes minus string_ui (SUI,lang)|N|Every <tt>SUI</tt>,<tt>language</tt> in the <tt>foreign_classes</tt> table must be found in the <tt>string_ui</tt> table.  This query returns <tt>SUI</tt>,<tt>language</tt> tuples than violate this condition.|0|||
string unique identifier integrity|select lui,language from foreign_classes minus select lui,language from string_ui|Rows in foreign_classes minus string_ui (LUI,lang)|N|Every <tt>LUI</tt>,<tt>language</tt> in the <tt>foreign_classes</tt> table must be found in the <tt>string_ui</tt> table.  This query returns <tt>LUI</tt>,<tt>language</tt> tuples than violate this condition.|0|||
string unique identifier integrity|select a.sui, b.atom_id from string_ui a,classes b, normstr c where a.sui=b.sui AND b.atom_id =c.normstr_id AND a.norm_string != c.normstr|Mismatches in string_ui,classes,normstr|N|Every atom in <tt>classes</tt> should have the same normalized string if it is looked up via <tt>SUI</tt> in <tt>string_ui</tt> or by <tt>normstr_id</tt> in <tt>normstr</tt>.  This query retuns <tt>SUI,atom_id</tt> tuples where the <tt>normstr</tt> from the <tt>normstr</tt> table does not equal the <tt>norm_string</tt> in the <tt>string_ui</tt> table.|0|||
unique identifier (ui) integrity|select atomic_action_id from atomic_actions where atomic_action_id > (select max_id from max_tab where table_name='ATOMIC_ACTIONS')|atomic_action_id out of range(atomic_actions)|N|An <tt>atomic_action_id</tt> found in atomic_actions must never be greater than the <tt>max_id</tt> for atomic_actions in the max_tab table.  This query returns <tt>atomic_action_id</tt>'s that violate this condition.|0|||
unique identifier (ui) referential integrity|select atom_id from classes where tobereleased != 'N' and language in ('ENG','SPA') minus select atom_id from word_index|Rows in classes minus word_index|Y|This may be off due to the addition/subtraction of atoms which have no <i>words</i>.  Edit the adjustment value to return count to 0.

For cases that keep recurring, use a query similar to the one below:

<pre>insert into word_index select atom_id,lower(atom_name) from atoms where atom_id in
(13782801, 13785179, 13789102, 13791762, 13792834, 13798882);</pre>
|25|Atoms with names comprised entirely of words that wordind does not consider words (like 'in').
<pre>2937942 =
2937943 <=
2937944 >=
2937945 <
2937946 >
2938034 %
2944148 +
2944149 ++
2944150 +++
2944151 ++++
11934006 %
12409813 +
12409815 ++
12409817 +++
12409819 ++++
12448386 =
12448388 <=
12448390 >=
12448392 <
12448394 >
39081708 %
39081712 %
39081713 %
39081735 %
39081736 %
</pre>||
unique identifier (ui) referential integrity|select atom_id from word_index minus (select atom_id from classes union all select atom_id from foreign_classes)|Rows in word_index minus classes|N|This query retuns <tt>atom_id</tt>'s from the <tt>word_index</tt> table that do not match any <tt>atom_id</tt>'s in the <tt>classes</tt> or <tt>foreign_classes</tt> tables.|0|||
other referential integrities|select /*+ PARALLEL(cr) */ relationship_id from context_relationships cr where tobereleased in ('Y','y') and source NOT IN (select current_name from source_version)|CR with invalid source|N|Every source in the context_relationships table must have current source and its coresponding ranking in the <tt>source_rank</tt> table.  This query returns <tt>relationship_id</tt>'s which have a source that is not found in the <tt>source_rank</tt> table. <p>There are two possible fixes for this problem:<ol><li>If the source is valid in <tt>context_relationships</tt>, then add it to <tt>source_rank</tt></li><li>If the source is NOT valid, then change it in <tt>context_relationships</tt></li></ol>|0|||
rxnorm semantics|select a.atom_id_1, a.concept_id_1 as concept_id from relationships a, atoms b where a.source='NLM02' and a.relationship_attribute='constitutes' and a.relationship_level='S' and a.tobereleased in ('Y','y') and a.atom_id_2=b.atom_id group by a.atom_id_1, a.concept_id_1, lower(atom_name) having count(*)>1|Duplicate components|Y|It is a serious problem for the RxNorm editor if a normal form has two relationships to identical components (not the samea tom but the same string).  This query finds such cases so they can be cleaned up.  Finding the min(relationship_id) in these cases and removing it should solve the problem.|0||DECLARE x number;  BEGIN MEME_UTILITY.drop_it('table', 'tjfw_$$');  EXECUTE IMMEDIATE 'create table tjfw_$$ as select min(relationship_id) as row_id from relationships a, atoms b where a.source=''NLM02'' and a.relationship_attribute=''constitutes'' and a.relationship_level=''S'' and a.tobereleased in (''Y'',''y'') and a.atom_id_2=b.atom_id group by a.atom_id_1, a.concept_id_1, lower(atom_name) having count(*)>1';  x:=MEME_BATCH_ACTIONS.macro_action( action=>'D', id_type=>'R', authority=>'L-JFW', table_name=>'tjfw_$$', work_id=>0, status=>'R');  MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
rxnorm semantics|select a.concept_id, a.atom_id from classes a, atoms b where a.source='NLM02' and a.termgroup='NLM02/SY' and a.tobereleased in ('Y','y') and a.atom_id = b.atom_id and b.atom_name not like '%0%' and b.atom_name not like '%1%' and b.atom_name not like '%2%' and b.atom_name not like '%3%' and b.atom_name not like '%4%' and b.atom_name not like '%5%' and b.atom_name not like '%6%' and b.atom_name not like '%7%' and b.atom_name not like '%8%' and b.atom_name not like '%9%'|Underspecified releasable SY|Y|NLM02/SY atoms should be unreleasable if they do not contain strength/units information.  This query does a best approximation of an underspecified SY and finds those cases
that appear to be releasable but without strength (it identifies cases without numbers).|0|||
other referential integrities|select initials,name from editors minus select initials,name from editor_preferences|Editor preferences misaligned|N|MEME4 requires that editor_preferences contains a row for each editor listed in the editors table.  This query finds cases that violate this rule.  Fixing the problems should be as easy as this:<pre>insert into editor_preferences select name,initials,1,1,1,1 from (select initials,name from editors minus select initials,name from editor_preferences);</pre>
|0||insert into editor_preferences select name,initials,1,1,1,1 from (select initials,name from editors minus select initials,name from editor_preferences)|
rxnorm semantics|select distinct sy.concept_id from classes sy, classes sbd, relationships sbddf, relationships sbdsy, relationships sbdin, atoms df, atoms ing, atoms sya where sy.source = 'NLM02' and sy.termgroup='NLM02/SY' and sy.atom_id = sya.atom_id and sbd.source = 'NLM02' and sbd.termgroup='NLM02/SBD' and sbd.tobereleased='Y' and sbddf.atom_id_1 = sbd.atom_id and sbddf.atom_id_2 = df.atom_id and sbddf.relationship_attribute='dose_form_of' and sbddf.source='NLM02' and sbddf.relationship_level='S' and sbdin.atom_id_1 = sbd.atom_id and sbdin.atom_id_2 = ing.atom_id and sbdin.relationship_attribute='ingredient_of' and sbdin.source='NLM02' and sbdin.relationship_level='S' and sbdsy.atom_id_1=sbd.atom_id and sbdsy.atom_id_2=sy.atom_id and sbdsy.relationship_name='SFO/LFO' and sbdsy.source='NLM02' and sbdsy.relationship_level='S' and lower(sya.atom_name) not like lower(ing.atom_name) || '%' || lower(df.atom_name)|Mismatched synonym name|Y|The SY name should start with the branded ingredient name and should end with the dose form.  Find cases where this is not true.|0|||
rxnorm semantics|select distinct sbd.concept_id from classes sbd, relationships sbdin, atoms ing, atoms sbda where sbd.source = 'NLM02' and sbd.termgroup='NLM02/SBD' and sbd.tobereleased='Y' and sbdin.atom_id_1 = sbd.atom_id and sbdin.atom_id_2 = ing.atom_id and sbdin.relationship_attribute='ingredient_of' and sbdin.source='NLM02' and sbdin.relationship_level='S' and sbd.atom_id = sbda.atom_id and lower(sbda.atom_name) not like '% [' || lower(ing.atom_name) || ']'|Mismatched trade name|Y|The SBD name should have the actual name of the ingredient to which it is connected in brackets at the end of its name. This check identifies concepts where this is not the case. These cases can be fixed by identifying an NLM02/BN atom with the name actually in the brackets and re-connecting the ingredient_of relationship to this new atom.|0|||
rxnorm semantics|select distinct scdc.atom_id, scdc.concept_id, inga.atom_id as ing_id from classes scdc, atoms scdca, atoms inga, relationships scdcin where scdc.source = 'NLM02' and scdc.termgroup='NLM02/SCDC' and scdc.tobereleased='Y' and scdc.atom_id=scdca.atom_id and scdcin.atom_id_1=scdc.atom_id and scdcin.atom_id_2=inga.atom_id and scdcin.source='NLM02' and scdcin.relationship_attribute='ingredient_of' and scdcin.relationship_level='S' and lower(scdca.atom_name) not like lower(inga.atom_name)||'%'|~ Mismatched component name|Y|These are cases of components whose name does not match its base ingredient.  If the other mismatched component check returns a zero, then these are the cases of concepts which are expressed in terms of their precise ingredients.
|0|||
rxnorm semantics|select distinct scdc.atom_id, scdc.concept_id from classes scdc, atoms scdca, atoms inga, relationships scdcin, relationships scdcpin, atoms pinga where scdc.source = 'NLM02' and scdc.termgroup='NLM02/SCDC' and scdc.tobereleased='Y' and scdc.atom_id=scdca.atom_id and scdcin.atom_id_1=scdc.atom_id and scdcin.atom_id_2=inga.atom_id and scdcin.source='NLM02' and scdcin.relationship_attribute='ingredient_of' and scdcin.relationship_level='S' and scdcpin.atom_id_1=scdc.atom_id and scdcpin.atom_id_2=pinga.atom_id and scdcpin.source='NLM02' and scdcpin.relationship_attribute='precise_ingredient_of' and scdcpin.relationship_level='S' and lower(scdca.atom_name) not like lower(inga.atom_name)||'%' and lower(scdca.atom_name) not like lower(pinga.atom_name)||'%'|Mismatched component name (ping and ing)|Y|The component name should match either its base ingredient or its precise ingredient.  This check returns cases where neither is true, meaning the component is different from both of its ingredients.|0|||
unique identifier (ui) integrity|select rui, relationship_level, relationship_name, '' relationship_attribute, to_char(concept_id_1) sg_id_1, to_char(concept_id_2) sg_id_2, 'MTH' root_source  from relationships a  where a.relationship_level = 'C'    and source not in ('MTHRELA','NLM03') and tobereleased in ('Y','y')  minus  select rui, relationship_level, relationship_name, relationship_attribute,   sg_id_1, sg_id_2, root_source   from relationships_ui where root_source='MTH'|Bad RUI (C rels - relationships_ui)|N|Finds cases where concept level relationships have incorrect RUI assignments.  Violations should be rare.|0|||
unique identifier (ui) integrity|select rui from relationships_ui group by rui having count(*)>1|Duplicate RUI (relationships_ui)|N|Finds cases where a single RUI value appears more than once in
<tt>relationships_ui</tt>.  Violation
s are fixed like this:<ol>

<li> Find duplicate ruis
<pre>
drop table rui_dups;
create table rui_dups as select rui from relationships_ui
group by rui having count(*)>1;
</pre></li>
<li> Null them in relationships
<pre>
update relationships set rui  = null
where rui in (select * from rui_dups);
</pre></li>
<li> Null them in context relationships
<pre>
update context_relationships set rui = null
where rui in (select * from rui_dups);
</pre></li>
<li> Clear from relationships_ui
<pre>
delete from relationships_ui where rui in
(select rui from rui_dups);
delete from inverse_relationships_ui where rui in
(select rui from rui_dups);
delete from inverse_relationships_ui where inverse_rui in
(select rui from rui_dups);
</pre>
</li>
<li> Re-assign
<pre>
update max_tab set max_id =
(select to_number(substr(max(rui),2)) from relationships_ui)
where table_name='RUI';
exec meme_source_processing.assign_ruis('relationships','MTH',0);
exec meme_sourcE_processing.assign_ruis('context_relationships','MTH',0);
</pre>
</li>
</ol>
|0|||
unique identifier (ui) integrity|select atui, attribute_level, attribute_name, hashcode, DECODE(sg_type,'CONCEPT_ID',to_char(concept_id),sg_id), sg_type, 'MTH' root_source from attributes a  where a.attribute_level = 'C' and tobereleased in ('Y','y')  minus  select atui, attribute_level, attribute_name, hashcode,   sg_id, sg_type, root_source from attributes_ui b where root_source='MTH'|Bad ATUI (C rels - attributes_ui)|N|Finds cases where concept level attributes have incorrect ATUI assignments.  Violations should be rare.|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(a) */ attribute_id,a.attribute_name,a.atui,c.stripped_source  from attributes a, source_rank b, source_rank c, attributes_ui d  where a.atui=d.atui(+)  and a.attribute_level=d.attribute_level(+)  and a.attribute_name=d.attribute_name(+)  and a.hashcode=d.hashcode(+)  and a.sg_id=d.sg_id(+)  and a.sg_type=d.sg_type(+)  and c.stripped_source=d.root_source  and a.attribute_level = 'S'  and a.source = b.source(+)  and b.normalized_source = c.source  and tobereleased in ('Y','y')  and d.atui is null|Bad ATUI (S rels - attributes_ui)|N|Finds cases where source level attributes have incorrect ATUI assignments.  Violations should be rare.|0|||
unique identifier (ui) integrity|select /*+ parallel(a) */ sg_id, sg_type, sg_qualifier, root_source,  attribute_name, hashcode, attribute_level  from attributes_ui a group by sg_id, sg_type,    sg_qualifier, root_source,  attribute_name, hashcode, attribute_level   having count(*)>1|Duplicate ATUI values (attributes_ui)|N|The values that compose a ATUI should not be duplicated with different ATUI values.  Fix using code like this:
<pre>
drop table atui_dups;
create table atui_dups as
select /*+ parallel(a) */ sg_id, sg_type,sg_qualifier,
root_source,attribute_level, attribute_name,hashcode
from attributes_ui a group by
 sg_id,sg_type,sg_qualifier,
root_source,attribute_level, attribute_name,hashcode
having count(*)>1;

drop table tfix;
create table tfix as
select min(atui) new_atui, max(atui) atui
from attributes_ui a
where (sg_id,sg_type,
nvl(sg_qualifier,'null'),
root_source,attribute_level,
attribute_name,hashcode
) in (select sg_id,sg_type,
nvl(sg_qualifier,'null'),
root_source,attribute_level,
attribute_name,hashcode
from atui_dups b)
and sg_id in (select sg_id from atui_dups)
group by
sg_id,sg_type,
sg_qualifier,
root_source,attribute_level,
attribute_name,hashcode;

create index xtfix on tfix(atui) compute statistics parallel;

update attributes a set atui =
(select new_atui  from tfix b where a.atui=b.atui)
where atui in (select atui from tfix);
delete from attributes_ui where atui in (select atui from tfix);

drop table tfix;
drop table atui_dups;
// copy changes to mrd
</pre>|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(a) */ concept_id, attribute_id from attributes a where atui is null and tobereleased in ('Y','y')|Releasable attribute with null ATUI|Y|Every releasable attribute must have a non-null ATUI.  Violations can be fixed by running MEME_SOURCE_PROCESSING.assign_atuis.|0|||
unique identifier (ui) integrity|select concept_id, atom_id from classes where aui is null and tobereleased in ('Y','y')|Releasable atom with null AUI|Y|Every releasable atom must have a non-null AUI.  Violations can be fixed by running MEME_SOURCE_PROCESSING.assign_auis.|0|||
new src integrities|select current_name from source_version a, source_rank b where current_name = b.source and b.source = normalized_source minus select source from sims_info where citation is not null|Current source without citation|Y|Each current source must have a citation.  The problem may be due to missing sims_info entries or stale information in source_rank.  First, check if there is any live data in the core tables connected to this source.  If there is, add sims_info rows either from dead_sims_info OR by loading the src file for those rows, and running the following query:
<pre>
UPDATE sims_info a
            SET (source_official_name ,
                nlm_contact ,
                acquisition_contact ,
                content_contact ,
                license_contact ,
                inverter_contact ,
                context_type ,
                language ,
                release_url_list ,
                valid_start_date ,
                citation ,
                license_info ,
                character_set ,
                rel_directionality_flag ) = 
                (select
                 source_official_name ,
                nlm_contact ,
                acquisition_contact ,
                content_contact ,
                license_contact ,
                inverter_contact ,
                context_type ,
                language ,
                release_url_list ,
                valid_start_date ,
                citation ,
                license_info ,
                character_set ,
                rel_directionality_flag   from source_source_rank b             
             WHERE a.source = high_source)
             where source in (select high_source from source_source_rank);
</pre>

Otherwise, delete the offending rows from source_rank.|0|||
unique identifier (ui) referential integrity|select normwrd_id from normwrd minus select atom_id from classes|Rows in normwrd minus classes|N|This query retuns <tt>normwrd_id</tt>'s from the normwrd table that do not match any <tt>atom_id</tt>'s in the classes table.  (Note: normwrd_id's are equivalent in value to atom_id's).|0|||
rxnorm semantics|select concept_id from classes where source='NLM02' and termgroup='NLM02/SCDF' and tobereleased in ('Y','y') group by concept_id having count(distinct sui)>1|~ Drug and form merges (SUI)|Y|Any concept containing an normalized drug and form atom (SCDF) should have only atoms with the same case-sensitive string.  This check identifies concepts containing SCDF atoms with different case-sensitive strings.|0|||
rxnorm semantics|select distinct a.concept_id from classes a, classes b where a.tobereleased in ('Y','y') and a.source='NLM02' and a.tty='BN' and a.concept_id = b.concept_id and b.tobereleased in ('Y','y') and b.source='NLM02' and b.tty !='BN'|~ BN/Non-BN merges|Y|Branded ingredients should never be in the same concept as other RXNORM atoms.|0|||
rxnorm semantics|select distinct a.concept_id from classes a, classes b where a.tobereleased in ('Y','y') and a.source='NLM02' and a.tty='IN' and a.concept_id = b.concept_id and b.tobereleased in ('Y','y') and b.source='NLM02' and b.tty !='IN'|~ IN/Non-IN merges|Y|Ingredients should never be in the same concept as other RXNORM atoms.|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(r) */ rui from relationships_ui r minus select /*+ PARALLEL(ir) */ rui from inverse_relationships_ui ir|Inverse RUI check|N|Every RUI in <tt>relationships_ui</tt> should be in <tt>inverse_relationships_ui</tt>. This is a serious problem that will affect the building of MRREL if it is not the case.|0|||
rxnorm semantics|SELECT a.concept_id, d.atom_name, c.atom_name,SUBSTR(c.atom_name,length( rtrim(substr(d.atom_name,instr(d.atom_name,' [')+2),']'))+1) FROM classes a, classes b, atoms c, atoms d, relationships r WHERE a.source = 'NLM02' and a.termgroup='NLM02/SY' AND b.source = 'NLM02' and b.termgroup='NLM02/SBD' AND b.tobereleased in ('Y','y') AND a.atom_id = c.atom_id AND b.atom_id = d.atom_id AND r.relationship_name='SFO/LFO' AND atom_id_2=a.atom_id AND atom_id_1=b.atom_id AND b.atom_id in (SELECT atom_id_1 FROM relationships WHERE relationship_attribute='constitutes' AND tobereleased in ('Y','y') AND source = 'NLM02' and relationship_level = 'S' GROUP BY atom_id_1 HAVING count(*) = 1) AND TRANSLATE(c.atom_name,'0123456789','^^^^^^^^^^') like '%^%' AND d.atom_name not like '%' || SUBSTR(c.atom_name,length( rtrim(substr(d.atom_name,instr(d.atom_name,' [')+2),']'))+1) || ' [' ||  rtrim(substr(d.atom_name,instr(d.atom_name,' [')+2),']') || ']'|Bad SY Name|Y|When the SY name has units, the units and strength values should match the SBD.  This check identifies cases where there is a mismatch between the SY and the SBD based on the units or strength.  These cases should be manually repaired.|0|||
other referential integrities|(select tty from classes where tobereleased in ('Y','y') union select tty from foreign_classes where tobereleased in ('Y','y')) minus select value from meme_properties where key_qualifier='TTY'|classes.tty minus MRDOC.tty|N|This check verifies that all ttys in classes are in MRDOC.  To add missing entries, use the <a href="/webapps-meme/meme/controller?state=MRDOCEditor">MRDOC editor</a>.|0|||
other referential integrities|select  decode(relationship_name,    'RT','RO','BT','RB',    'NT','RN','LK','RL','RT?','RQ',    'BBT','RB','BNT','RN','BRT','RO',relationship_name) from inverse_relationships minus select value from meme_properties where key_qualifier='REL'|inverse_relationships.rel minus MRDOC.rel|N|This check verifies that all inverse relationships are in MRDOC.  To add missing entries, use the <a href="/cgi-lti-oracle/meme_properties.cgi">MEME properties editor</a>.|7|There are 7 exceptions, the following rels are either not used or are not released:<ul>
<li>BT? - not used</li>
<li>LEX - not used</li>
<li>LFO - not used</li>
<li>NT? - not used</li>
<li>SFO - not used</li>
<li>SFO/LFO - not released</li>
<li>XS - not released</li><ul>

||
other referential integrities|(select /*+ parallel(r) */ relationship_attribute from relationships r where tobereleased in ('Y','y') minus select value from meme_properties where key_qualifier='RELA') union (select /*+ parallel(a) */ inverse_rel_attribute from relationships a, inverse_rel_attributes b where a.relationship_attribute = b.relationship_attribute and tobereleased in ('Y','y') minus select value from meme_properties where key_qualifier='RELA')|relationships.rela minus MRDOC.rela|N|This check verifies that all relationship attributes are in MRDOC.  To add missing entries, use the <a href="/webapps-meme/meme/controller?state=MRDOCEditor">MRDOC editor</a>.  (For the EXPLAIN section, enter the name of the rela with the first word capitalized and spaces instead of underscores.)|0|||
other referential integrities|select /*+ PARALLEL(a) */ attribute_name from attributes a where tobereleased in ('Y','y') minus select value from meme_properties where key_qualifier='ATN'|attributes.atn minus MRDOC.atn|N|This check verifies that all attribute names are in MRDOC.  To add missing entries, use the <a href="/webapps-meme/meme/controller?state=MRDOCEditor">MRDOC editor</a>.|8|There are 8 exceptions:
<ul><li>COC</li><li>DEFINITION</li><li>LEXICAL_TAG</li><li>NON_HUMAN</li><li>SEMANTIC_TYPE</li><li>XMAP</li><li>XMAPTO</li><li>XMAPFROM</li></ul>

These two used to be here but are gone now:
<ul><li>HDA</li><li>HPC</li></ul>||
other referential integrities|select language from foreign_classes where tobereleased in ('Y','y') minus select value from meme_properties where key_qualifier='LAT'|languages.lat minus MRDOC.lat|N|This check verifies that all foreign languages are in MRDOC.  To add missing entries, use the <a href="/cgi-lti-oracle/meme_properties.cgi">MEME properties editor</a>.|0|||
other referential integrities|select relationship_attribute from context_relationships where tobereleased in ('Y','y') minus select value from meme_properties where key_qualifier='RELA'|context.relationships.rela minus MRDOC.rela|N|This check verifies that all context relationship attributes are included in MRDOC.  To add missing entries, use the <a href="/cgi-lti-oracle/meme_properties.cgi">MEME properties editor</a>.|0|||
other referential integrities|select map_rela from meow.mappings_for_dead_cuis minus select value from meme_properties where key_qualifier='RELA'|mappings_for_dead_cuis.map_rela minus MRDOC.rela|N|This check verifies that all relationship attributes are included in MRDOC.  To add missing entries, use the <a href="/cgi-lti-oracle/meme_properties.cgi">MEME properties editor</a>.|0|||
core table semantics|select /*+ PARALLEL(b) */ a.atom_id,a.attribute_id,a.source as s1,b.source as s2 from attributes a, classes b where attribute_level='S' and a.tobereleased in ('Y','y') and a.source in (select current_name from source_version) and a.atom_id=b.atom_id and a.source not like 'E-%'  and a.attribute_name !='LEXICAL_TAG' and b.tobereleased in ('N','n')|Current ver attribute connected to old atom|N|This check finds current version attributes connected to atoms with non-current versions. LEXICAL_TAGs are ignored.  Try running the auto fix first.  
<p>Otherwise, to fix this use code similar to the following: <pre><blockquote>@$MEME_HOME/sql/as<br><br>drop table tkao;<br>create table tkao as<br>select /*+ PARALLEL(b) */ a.atom_id,a.attribute_id,a.source as s1,b.source as s2 from attributes a, classes b 
where attribute_level='S' and a.tobereleased in ('Y','y') and a.source in (select current_name from source_version) 
and b.tobereleased in ('N','n') 
and a.atom_id=b.atom_id and a.source not like 'E-%' and a.attribute_name !='LEXICAL_TAG';<br><br>drop table tkao2;<br>create table tkao2 as<br>select * from attributes where attribute_id in<br> (select attribute_id from tkao where s1!= 'NLM02');<br><br>update tkao2 set atom_id=0, concept_id=0, atui = null;<br>commit;<br><br>create index x_tkao2 on tkao2(attribute_id) compute statistics parallel;<br><br>exec meme_source_processing.map_sg_fields('tkao2','N','Y','Y');<br>exec meme_source_processing.assign_atuis('tkao2','MTH',0);<br><br>delete from attributes where attribute_id in<br>(select attribute_id from tkao2);<br><br>insert into attributes select * from tkao2;<br><br>commit;</blockquote></pre>

OR

<pre><blockquote>drop table t1;
create table t1 as
select /*+ parallel(a) */ a.atom_id,a.attribute_id,a.source as s1,b.source as s2
 from attributes a, classes b where attribute_level='S'
 and a.tobereleased in ('Y','y')
 and a.source in (select current_name from source_version)
 and b.source not in (select current_name from source_version)
 and a.atom_id=b.atom_id
 and a.source not like 'E-%';
 
drop table t2;
create table t2 as
select attribute_id,atom_id,sg_id,
sg_type,sg_qualifier
from attributes where attribute_id in 
(select attribute_id from t1);

... (create indices as needed)

BEGIN MEME_SOURCE_PROCESSING.map_sg_fields('t2','N','N','Y'); END;
/

drop table t3;
create table t3 as
select a.attribute_id as row_id, 
a.atom_id as old_value, b.atom_id as new_value 
from attributes a, t2 b 
where a.attribute_id=b.attribute_id 
and a.atom_Id!=b.atom_id;

...

batch.pl -a=A -t=A -s=t t3 oa_mid2005 L-JFW</blockquote></pre>|0||BEGIN MEME_SOURCE_PROCESSING.map_sg_data('MTH',0); END;|
other referential integrities|select concept_id,atom_id from classes where suppressible !='Y' and termgroup='MTH/MM' and source='MTH'|MTH/MM atoms that are not suppressible|Y|MTH/MM atoms should be suppressible.  This check finds cases where they are not.|0|||
unique identifier (ui) integrity|select min(concept_id) as concept_id, aui from classes where tobereleased in ('Y','y') group by aui having count(distinct concept_id)>1|~ AUI split across CUI|Y|AUI should be a unique id across classes where things are   releasable.  Violations should be NLM02 things and should be resolved by the end of editing.|0|||
core table semantics|select /*+ parallel(b) */ attribute_id, relationship_id, concept_id, a.source as s1, b.source as s2 from attributes a, relationships b where sg_meme_id = b.relationship_id    and a.tobereleased in ('Y','y') and sg_meme_data_type='R'  and a.source in (select current_name from source_version) and b.source not in (select current_name from source_version)|Current ver attribute connected to old ver rels|N|Attributes connected to relationships should only be current
versions if the relationships are also current versions.|0|||
core table semantics|select /*+ parallel(b) */ attribute_id, relationship_id, concept_id, a.source as s1, b.source as s2 from attributes a, context_relationships b where sg_meme_id = b.relationship_id and a.tobereleased in ('Y','y') and sg_meme_data_type='R' and a.source in (select nvl(current_name,'null') from source_version) and b.source not in (select current_name from source_version)|Current ver attribute connected to old ver cxt rels|N|Attributes connected to context relationships should only be current versions if the relationships are also current versions.|0|||
core table semantics| select attribute_id, substr(attribute_value,1,8) as cui from attributes where tobereleased in ('Y','y') and attribute_name='XMAPFROM' and attribute_value like 'C%' and not exists (select /*+ INDEX (cs, x_cs_cui) */ cui from concept_status cs where cui = substr(attribute_value,1,8))|~ ATX mappings connected to bad CUIs|N|This check finds ATX mappings whose CUI fields are invalid.|0|||
new src integrities|select distinct concept_id from classes where source='SRC' and termgroup in ('SRC/VAB','SRC/VPT','SRC/VSY') and tobereleased in ('Y','y') and concept_id in (select concept_id from classes where termgroup not in  ('SRC/VAB','SRC/VPT','SRC/VSY','MTH/MM','MTH/TM','MTH/PN') and tobereleased in ('Y','y'))|Bad termgroup in versioned SRC concept|Y|Versionless <tt>SRC</tt> concepts are only allowed to contain atoms from one of six termgroups: <tt>SRC/VAB</tt>, <tt>SRC/VPT</tt>, <tt>SRC/VSY</tt>, <tt>MTH/MM</tt>, <tt>MTH/TM</tt>, <tt>MTH/PN</tt>.  This check returns concept ids that violate this condition.  Violations can be fixed by removing the offending termgroups or using the adjustment mechanism.

When the result is negative, this typically means a new version of SNOMEDCT or SCTSPA has been inserted and not yet merged with the atom from the source that names itself.|3|Exceptions are: <ul>
<li>RCD99 - 7178125 - names itself</li>
<li>Versioned SNOMEDCT_2007_01_31 - 44580766 - names itself</li>
<li>Versioned SCTSPA_2006_10_31 - 43014404 - names itself</li>
</ul>||
other referential integrities|select  relationship_attribute from inverse_rel_attributes minus select value from meme_properties where key_qualifier='RELA'|inverse_rel_attributes.rela minus MRDOC.rela|N|This check verifies that all inverse relationship attributes are in MRDOC.  To add missing entries, use the <a href="/webapps-meme/meme/controller?state=MRDOCEditor">MRDOC editor</a>.|0|||
core table semantics|select concept_id_1 as concept_id, concept_id_2, r.source, a.atom_name as atom_1, b.atom_name as atom_2  from relationships r, atoms a, atoms b   where relationship_name='SFO/LFO' and concept_id_1 != concept_id_2 and r.atom_id_1 = a.atom_id and atom_id_2=b.atom_id order by 3|~~ SFO/LFO relationships spanning concepts|Y|SFO/LFO relationships should not span concepts.  This finds cases that do so that editors can resolve them.  This check is also performed by the sfo_lfo EMS QA bin.|0|||
new src integrities|select distinct concept_id,code from classes  where source='SRC'   and termgroup in ('SRC/RAB','SRC/RPT','SRC/RSY','SRC/RHT','SRC/SSN')   and tobereleased in ('Y','y') and concept_id in   (select concept_id from  (select /*+INDEX(a,x_classes_cid)*/ concept_id,lui from classes a where termgroup not in    ('SRC/RAB','SRC/RPT','SRC/RSY','SRC/RHT','SRC/SSN','MTH/MM','MTH/TM','MTH/PN') and tobereleased in ('Y','y')  and concept_id in (select concept_id from classes where source='SRC')  minus  select concept_id,lui from classes where source='SRC' and termgroup in    ('SRC/RAB','SRC/RPT','SRC/RSY','SRC/RHT','SRC/SSN') and tobereleased in ('Y','y')))|Bad termgroup in root SRC concept|Y|Root <tt>SRC</tt> concepts are generally only allowed to contain atoms from one of eight termgroups: <tt>SRC/RAB</tt>, <tt>SRC/RPT</tt>, <tt>SRC/RSY</tt>, <tt>SRC/RHT</tt>, <tt>SRC/SSN</tt>, <tt>MTH/MM</tt>, <tt>MTH/TM</tt>, <tt>MTH/PN</tt>.  This check returns concept ids that contain atoms from other sources whose LUIs do NOT match the LUIs of the allowed atoms.  Violations can be fixed by removing the offending termgroups or using the adjustment mechanism.  Occasionally sources will name themselves or other sources and those atoms will be merged into the root SRC concept.  |20|Current exceptions include:<ol>
<li>PDQ - 1021 - named by MSH</li>
<li>MTH - 1565 - named by MSH</li>
<li>RCD - 118830 - named by RCD</li>
<li>MED - 1094383 - named by MSH</li>
<li>DSM4 - 1411141 - named by AOD,MSH</li>
<li>MSH - 6598515 - named by MSH</li>
<li>LOINC - 7047015 - named by MSH </li>
<li>ICD9CM - 7050793 - named by MSH</li>
<li>GO - 7147522 - named by NCI</li>
<li>CPT - 7177960 - named by HL7</li>
<li>CST - 7177969 - named by HL7, NCI</li>
<li><s>OMS - 7178006 - named by HL7</s></li>
<li>UMD - 7178025 - named by HL7</li>
<li>WHO - 7178033 - named by HL7, NCI</li>
<li>ICD10 - 7178087 - named by MSH</li>
<li>HCPCS - 7178099 - named by MSH</li>
<li>NCI - 7178158 - named by itself</li>
<li><s>MMSL - 7178251 - named by HL7</s></li>
<li>MDR - 7178346 - named by NCI</li>
<li>SCTSPA - 11349864 - named by itself</li>
<li>CTCAE - 17741472 - named by NCI</li>
<li>SNOMEDCT - 22361609 - named by MSH</li>
</ol>||
new src integrities|select current_name from source_version where current_name is not null minus select source from source_rank|source_version.current_name minus source_rank|N|Every <tt>current_name </tt>in <tt>source_version</tt> must be represented in the <tt>source</tt> field of <tt>source_rank</tt>. Violations of this check should be fixed by either removing <tt>source_version</tt> data or adding <tt>source_rank</tt> data.|0|||
new src integrities|select source from source_version minus select stripped_source from source_rank|source_version.source minus source_rank|N|Every <tt>source</tt> in <tt>source_version</tt> must exist in the <tt>stripped_source</tt> field of <tt>source_rank</tt>.  The inverse of this is also true for sources whose versioned SAB matches their normalized SAB. Violations should be fixed by adjusting <tt>source_version</tt> or <tt>source_rank</tt> data.|0|||
new src integrities|select stripped_source from source_rank where source=normalized_source minus select source from source_version|source_rank.stripped_source minus source_version|N|Every <tt>stripped_source</tt> in <tt>source_rank</tt> must exist in the <tt>source</tt> field of <tt>source_version</tt> where the versioned SAB matches the normalized SAB.  The inverse of this is also true. Violations should be fixed by adjusting <tt>source_version</tt> or <tt>source_rank</tt> data.|0|||
new src integrities|select a.atom_name a from atoms a, atoms b, classes c, classes d, sims_info e where a.atom_id=c.atom_id and b.atom_id=d.atom_id and c.source='SRC' and d.source='SRC' and c.tobereleased ='Y' and d.tobereleased='Y' and c.termgroup='SRC/VAB' and d.termgroup='SRC/VPT' and c.concept_id=d.concept_id and b.atom_name != e.source_official_name and a.atom_name = e.source|Official Name does not match SRC/VPT|N|The official name of a versioned source (as it appears in MRSAB) should match the SRC/VPT atom name for that source.  This check returns versioned source names for which this is not the case.  To fix the problem run: "Set official name" off of <tt><a href="/cgi-lti-oracle/release_maintenance.cgi">/cgi-lti-oracle/release_maintenance.cgi</a></tt>.|0|||
core table semantics|select /*+ PARALLEL(a) */ concept_id, atom_id from classes a where tobereleased in ('Y','y') and (code like ' %' or code like '% ')|Codes with leading/trailing spaces|Y|Code values should not have leading or trailing spaces.|0|||
new src integrities|select distinct a.concept_id from classes a, classes b, atoms c where a.source='SRC' and b.source='SRC' and b.termgroup='SRC/RAB' and a.code != concat('V-',c.atom_name) and b.atom_id=c.atom_id and a.concept_id=b.concept_id and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')|Code does not match SRC/RAB name|Y|Every SRC atom in a root SRC concept must have a code equal to V- appended to the <tt>SRC/RAB</tt> atom name from that same concept.  For example, in the <tt>MSH</tt> SRC concept, all SRC atoms should have a code equal to <tt>V-MSH</tt>.  Any violations of this check can be fixed by setting the invalid codes to the correct value.|0|||
rxnorm semantics|select atom_id_1 as atom_id ,concept_id_1 as concept_id from relationships a, classes b where a.source='NLM02' and relationship_attribute='precise_ingredient_of' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/IN' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y') group by atom_id_1,concept_id_1 having count(*) >1|Component with too many precise ingredients|Y|Every component must be connected to exactly one precise ingredient.  This check returns cases which are connected to more than one.  To fix this, run the auto fix for "Duplicate RxNorm relationships."|0|||
rxnorm semantics|select distinct concept_id from classes a, atoms b  where a.source = 'NLM02' and a.termgroup in ('NLM02/SCD','NLM02/SBD')  and a.atom_id = b.atom_id and lower(atom_name) like '%obsolete%'|~ Obsolete SBD or SCD atoms|Y|Normal forms should not be connected to obsolete ingredients.
Due to the way some drug sources work, it is possible that
a graph will be connected to an ingredient that contains
the word "obsolete".  This check identifies the normal forms
so that they and the corresponding ingredient concepts
can be updated.|0|||
rxnorm semantics|select atom_id_1 as atom_id, concept_id_1 as concept_id from relationships a, classes b where a.source='NLM02' and relationship_name='SFO/LFO' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup in ('NLM02/SCD','NLM02/SBD') and b.tobereleased in ('Y','y') group by atom_id_1, concept_id_1 having count(*) >1|CD with too many normal forms|Y|Every clinical drug must be connected to exactly one normal form.  This check returns cases which are not.|0|||
rxnorm semantics|select concept_id from classes where source='NLM02' and termgroup in ('NLM02/SCD','NLM02/SBD') and tobereleased in ('Y','y') minus select concept_id from classes where (source !='NLM02' OR tty in ('OBD','OCD')) and tobereleased in ('Y','y')|~ Normal form without clinical drug|Y|Every normal form must be connected to a clinical drug.  This check returns cases which are not.  (They may be obsolete.)|0|||
rxnorm semantics|select atom_id_1 as atom_id, concept_id_1 as concept_id from relationships a, classes b where a.source='NLM02' and relationship_name='SFO/LFO' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SY' group by atom_id_1,concept_id_1 having count(*) >1|Branded normal form with too many SY|Y|Every branded normal form must be connected to exactly one synonym.  This check returns cases which are not.|0|||
rxnorm semantics|select atom_id, concept_id from classes where source='NLM02' and termgroup='NLM02/SY' and tobereleased in ('Y','y') minus (select atom_id_2, concept_id_2 from relationships a, classes b where a.source='NLM02' and relationship_name='SFO/LFO' and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SBD')|SY without branded normal form|Y|Every synonym must be connected to a branded normal form.  This check returns cases which are not.|0|||
rxnorm semantics|select atom_id_2 as atom_id, concept_id_2 as concept_id from relationships a, classes b where a.source='NLM02' and relationship_name='SFO/LFO' and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SBD' group by atom_id_2, concept_id_2 having count(*) >1|SY with too many branded normal forms|Y|Every synonym must be connected to exactly one branded normal form.  This check returns cases which are not.|0|||
rxnorm semantics|select distinct sbd.concept_id from (select a.atom_id, concept_id, lower(b.atom_name) as atom_name from classes a, atoms b where a.atom_id = b.atom_id and tobereleased in ('y','y') and source = 'NLM02' and termgroup = 'NLM02/SCD' order by lower(b.atom_name)) scd, (select a.atom_id, concept_id, substr(lower(b.atom_name),1,instr(b.atom_name,'[',-1)-2) as atom_name from classes a, atoms b where a.atom_id = b.atom_id and tobereleased in ('y','y') and source = 'NLM02' and termgroup = 'NLM02/SBD' order by lower(b.atom_name)) sbd where scd.atom_name = sbd.atom_name minus (select concept_id_2 from relationships a, classes b where a.source='NLM02' and relationship_attribute='tradename_of' and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SCD' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|Branded normal form without tradename relationship|Y|Every branded normal form which matches a generic form in another concept must have a <tt>tradename_of</tt> relationship.  This check returns cases which do not.  It should be run after assigning <tt>tradename_of</tt> rels.|0|||
core table semantics|select /*+ parallel(cs) */  timestamp, count(*) ct from concept_status cs where tobereleased in ('Y','y') group by timestamp having count(*)>60000|too many concepts with same timestamp|N|Too many things were given the same timestamp, this is probably wrong and will contribute to problems when building the MRSAT MR (major revision date) attribute.  

To fix, reload timestamps from previous version of the release (the MR attributes) and update concept_status with them.  Then compute the max timestamp (not associated with MATRIXINIT) for a concept approval and update concept_status with that.|4|There are 4 known exceptions: 
<ul>
<li>24-oct-2001</li>
<li>01-jan-2003</li>
<li>24-aug-2004 03:53:03 - from SNOMEDCT/SCTSPA</li>
<li>15-jun-2006 15:19:02 - RXNORM code formats changed</li>
</ul>||
rxnorm semantics|select concept_id from classes a, atoms b where source='NLM02' and termgroup='NLM02/SY' and a.atom_id=b.atom_id and b.atom_name not like (select min('%'||atom_name) from relationships d, relationships e, atoms f where a.atom_id = d.atom_id_2 and d.source='NLM02' and d.relationship_name='SFO/LFO' and d.atom_id_1=e.atom_id_1 and e.source='NLM02' and e.relationship_attribute='dose_form_of' and e.atom_id_2=f.atom_id)|SY with bad dose form|Y|Branded Synonym atoms (NLM02/SY) need to have the same dose as the NLM02/SBD they are connected to.  This check returns concept ids that violate this rule.|0|||
rxnorm semantics|select atom_id from classes where source='NLM02' and termgroup='NLM02/SBD' and tobereleased in ('Y','y') minus (select atom_id_2 from relationships a, classes b where a.source='NLM02' and relationship_attribute='isa' and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SBDF' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y') group by atom_id_2 having count(*) = 1 )|Branded normal form without SBDF|Y|Every branded normal form must be connected to an semantic clinical branded drug and form.  This check returns cases which are not.|0|||
unique identifier (ui) referential integrity|select row_id from atomic_actions where table_name='C' minus (select atom_id from classes union all select atom_id from dead_classes)|Rows in atomic_actions (C) minus classes|N|This query retuns any <tt>row_id</tt>'s from the atomic_actions table with a <tt>table_name</tt> value equal to <tt>C</tt> (classes) that do not match to an <tt>atom_id</tt> in the classes or dead_classes tables.|0||BEGIN    meme_utility.drop_it('table','t_fix_$$');    execute immediate 'create table t_fix_$$ as select row_id from atomic_actions where table_name=''C'' minus (select atom_id from classes union all select atom_id from dead_classes)';    execute immediate 'insert into dead_atomic_actions select * from atomic_actions where table_name=''C'' and row_id in (select * from t_fix_$$)';    execute immediate 'delete from atomic_actions where table_name=''C'' and row_id in (select * from t_fix_$$)';  END;|
unique identifier (ui) referential integrity|select row_id from atomic_actions where table_name='R' minus (select relationship_id from relationships union all select relationship_id from dead_relationships)|Rows in atomic_actions (R) minus R|N|This query retuns any <tt>row_id</tt>'s from the atomic_actions table with a <tt>table_name</tt> value equal to <tt>R</tt> (relationships) that do not match to an <tt>relationship_id</tt> in the relationships or deadrelationships tables.|0|||
unique identifier (ui) referential integrity|select atom_id from atoms minus select atom_id from classes|Rows in atoms minus classes|N|This query retuns <tt>atom_id</tt>'s from the atoms table that do not match any <tt>atom_id</tt>'s in the classes table.|0|||
unique identifier (ui) integrity|select rui, relationship_level, relationship_name,     relationship_attribute, sg_id_1, sg_id_2, decode(source,'NLM03','RXNORM','MTHRELA','MTH')  from relationships a  where a.relationship_level = 'C'    and source in ('MTHRELA', 'NLM03') and tobereleased in ('Y','y')  minus  select rui, relationship_level, relationship_name, relationship_attribute,   sg_id_1, sg_id_2, root_source   from relationships_ui|Bad RUI (C rela rels - relationships_ui)|N|Finds cases where concept level NLM03 or MTHRELA relationships have incorrect RUI assignments.  Violations should be rare.|0|||
unique identifier (ui) integrity|select rui from inverse_relationships_ui group by rui having count(*)>1|Duplicate RUI (inverse_relationships_ui)|N|Finds cases where one RUI are mapped to more than one inverse RUI.  Violations should be rare.|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(iru) */ inverse_rui from inverse_relationships_ui iru group by inverse_rui having count(*)>1|Duplicate inverse RUI|N|Finds cases where one inverse RUI is mapped to more than one RUI.  Violations should be rare.|0|||
unique identifier (ui) integrity|select aui, sui, c.stripped_source, code, tty   from classes a, source_rank b, source_rank c  where a.source = b.source and a.source != 'NLM02'    and b.normalized_source = c.source    and tobereleased in ('Y','y')  minus  select aui, sui, stripped_source, code, tty   from atoms_ui|Bad AUI (classes - atoms_ui (!RXNORM))|N|This check finds cases of atoms that have been assigned incorrect AUIs.  To fix this problem, set the AUIs in classes to null and run MEME_SOURCE_PROCESSING.assign_auis.|0|||
unique identifier (ui) integrity|select aui, sui, 'RXNORM', tty   from classes a  where a.source = 'NLM02'    and tobereleased in ('Y','y')  minus  select aui, sui, 'RXNORM', tty   from atoms_ui where stripped_source = 'RXNORM'|Bad AUI (classes - atoms_ui (RXNORM))|N|This check finds cases of RXNORM atoms that have been assigned incorrect AUIs.  To fix this problem, set the AUIs in classes to null and run MEME_SOURCE_PROCESSING.assign_auis.|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(a) */  rui, relationship_level, relationship_name,     relationship_attribute,   sg_id_1, sg_id_2, c.stripped_source  from context_relationships a, source_rank b, source_rank c  where a.relationship_level = 'S' and a.source = b.source     and b.normalized_source = c.source    and tobereleased in ('Y','y')  minus  select /*+ PARALLEL(r) */  rui, relationship_level, relationship_name, relationship_attribute,   sg_id_1, sg_id_2, root_source   from relationships_ui r|Bad RUI (context rels - relationships_ui)|N|Finds cases where context relationships have incorrect RUI assignments.  Violations should be rare.|0|||
unique identifier (ui) integrity|select /*+PARALLEL(r)*/ sg_id_1, sg_type_1, sg_id_2, sg_type_2,   sg_qualifier_1, sg_qualifier_2, root_source,  relationship_name, relationship_attribute, relationship_level, source_rui from relationships_ui r group by sg_id_1, sg_type_1, sg_id_2, sg_type_2,   sg_qualifier_1, sg_qualifier_2, root_source,  relationship_name, relationship_attribute, relationship_level, source_rui   having count(*)>1|Duplicate RUI values (relationships_ui)|N|The values that compose a RUI should not be duplicated with different RUI values.  Fix using code like this:
<pre>
drop table rui_dups;
create table rui_dups as
select /*+ PARALLEL(r) */ 
sg_id_1,sg_id_2,sg_type_1,sg_type_2,sg_qualifier_1,sg_qualifier_2,
root_source,relationship_level, relationship_name,relationship_attribute, sourcE_rui
from relationships_ui r group by
 sg_id_1,sg_id_2,sg_type_1,sg_type_2,sg_qualifier_1,sg_qualifier_2,
root_source,relationship_level, relationship_name,relationship_attribute, source_rui
having count(*)>1;


drop table tfix;
create table tfix as
select /*+ parallel(r) */ min(rui) new_rui, max(rui) rui
from relationships_ui r
where (sg_id_1,sg_id_2,sg_type_1,sg_type_2,
nvl(sg_qualifier_1,'null'),nvl(sg_qualifier_2,'null'),
root_source,relationship_level,
relationship_name,nvl(relationship_attribute,'null'),
nvl(source_rui,'null')
) in (select /*+ parallel(b) */  sg_id_1,sg_id_2,sg_type_1,sg_type_2,
nvl(sg_qualifier_1,'null'),nvl(sg_qualifier_2,'null'),
root_source,relationship_level,
relationship_name,nvl(relationship_attribute,'null'),
nvl(source_rui,'null')
from rui_dups b)
group by
sg_id_1,sg_id_2,sg_type_1,sg_type_2,sg_qualifier_1,sg_qualifier_2,
root_source,relationship_level, relationship_name,relationship_attribute, source_rui;

create index xtfix on tfix(rui) compute statistics parallel;

update /*+ parallel(a) */ relationships a set rui =
(select new_rui  from tfix b where a.rui=b.rui)
where rui in (select rui from tfix);
update /*+ parallel(a) */ context_relationships a set rui =
(select new_rui  from tfix b where a.rui=b.rui)
where rui in (select rui from tfix);
delete from relationships_ui where rui in (select rui from tfix);
delete from inverse_relationships_ui where rui in (select rui from tfix);
delete from inverse_Relationships_ui where inverse_rui in (select rui from
tfix);

drop table tfix;
drop table rui_dups;
// copy changes to mrd
</pre>|0|||
string unique identifier integrity|select a.sui from string_ui a,classes b,atoms c where a.sui=b.sui AND b.atom_id =c.atom_id AND a.string != c.atom_name|Mismatches in string_ui,classes,atoms|N|Every <tt>SUI</tt> in the string_ui table has a corresponding <tt>string</tt>.  Every <tt>SUI</tt> in the classes table has a corresponding <tt>atom_id</tt>.  And every <tt>atom_id</tt> in the atoms table has a corresponding <tt>atom_name</tt>.  This query retuns <tt>SUI</tt>'s where the <tt>atom_name</tt> from the atoms table does not equal the <tt>string</tt> in the string_ui table; a condition which violates <tt>atom_name</tt> equal to <tt>string</tt> value for a given <tt>SUI</tt>.|0|||
string unique identifier integrity|select a.sui from string_ui a,dead_classes b,dead_atoms c where a.sui=b.sui AND b.atom_id =c.atom_id AND a.string != c.atom_name|Mismatches in string_ui,d_classes,d_atoms|N|Every <tt>SUI</tt> in the string_ui table has a corresponding <tt>string</tt>.  Every <tt>SUI</tt> in the dead_classes table has a corresponding <tt>atom_id</tt>.  And every <tt>atom_id</tt> in the dead_atoms table has a corresponding <tt>atom_name</tt>.  This query retuns <tt>SUI</tt>'s where the <tt>atom_name</tt> from the dead_atoms table does not equal the <tt>string</tt> in the string_ui table; a condition which violates <tt>atom_name</tt> equal to <tt>string</tt> value for a given <tt>SUI</tt>.|0|||
string unique identifier integrity|select lui from string_ui where lui not in (select lui from string_ui where lowercase_string_pre='in' and language='ENG') and norm_string IS NULL|Rows w/ non-null LUI & null norm_string|N|The <tt>LUI</tt> equal to L0028429 should be the only <tt>LUI</tt> with an empty (NULL) <tt>norm_string</tt> value in the string_ui table.  This query returns <tt>LUI</tt>'s from the string_ui table that violate this condition by having a NULL <tt>norm_string</tt>.|0|||
other referential integrities|select /*+ PARALLEL(r) */ relationship_id from relationships r where relationship_name NOT IN (select relationship_name from inverse_relationships)|Invalid relationship_name (R)|N|Every <tt>relationship_name</tt> in the relationships table must have the same <tt>relationship_name</tt> in the inverse_relationships table.  This query returns <tt>relationship_id</tt>'s where a <tt>relationship_name</tt> from the relationships table is not found in the inverse_relationships table.|0|||
other referential integrities|select /*+ PARALLEL(r) */ relationship_id from relationships r where relationship_attribute NOT IN (select relationship_attribute from inverse_rel_attributes)|Invalid relationship_attribute (R)|N|Every <tt>relationship_attribute</tt> in the relationships table must have the same <tt>relationship_attribute</tt> in the inverse_rel_attributes table.  This query returns <tt>relationship_id</tt>'s where a <tt>relationship_attribute</tt> in the table relationhsips is not found in the inverse_rel_attributes table.|0|||
other referential integrities|select relationship_name,inverse_name from inverse_relationships minus select inverse_name,relationship_name from inverse_relationships|Mismatched inverse_relationships|N|Every <tt>relationship_name</tt> in the table inverse_relationships must have a corresponding <tt>inverse_name</tt>.  This query return the <tt>relationship_name</tt> and the <tt>inverse_name</tt> fields that violate this condition.|0|||
core table semantics|select /*+ PARALLEL(r) */ concept_id_1 as concept_id, relationship_id from relationships r where status='R' and relationship_name IN ('RT?','LK') and relationship_level='C'|Illegal C level relationship (rn=RT?,LK,status=R)|Y|MTH asserted relationships are not allowed to be both approved (status=R) and have a <tt>relationship_name</tt> of <tt>RT?</tt> or <tt>LK</tt>.  This check returns <tt>concept_id</tt> and <tt>relationship_id</tt>s of the offending rows.  To fix this problem, use <tt>MEME_BATCH_ACTION.macro_action</tt> to change the status of these things back to <tt>N</tt>.|0|||
core table semantics|select /*+ PARALLEL(r) */ relationship_id,concept_id_1 as concept_id,concept_id_2 from relationships r where status='U' and concept_id_1 in (select concept_id from concept_status where status='R') and concept_id_2 in (select concept_id from concept_status where status='R') and tobereleased in ('Y','y')|Status U between two status R concepts|Y|Releasable status U relationships should not exist between status R concepts, but occasionally these cases arise.  To fix them, use the <tt>$MEME_HOME/Patch/status_U_rels.csh</tt> script.|0|||
other referential integrities|select relationship_name from inverse_relationships group by relationship_name having count(*)>1 union select inverse_name from inverse_relationships group by inverse_name having count(*)>1|Duplicates in inverse_relationships|N|This check looks for duplicate values in the <tt>relationship_name</tt> or <tt>inverse_name</tt> fields of the <tt>inverse_relationships</tt> table.  The duplicate values are returned.  To fix this check, idenfity the rows containing the duplicate values and select one to remove.|0|||
other referential integrities|select * from inverse_rel_attributes where relationship_attribute in (select relationship_attribute from inverse_rel_attributes group by relationship_attribute having count(*)>1 union select inverse_rel_attribute from inverse_rel_attributes group by inverse_rel_attribute having count(*)>1) order by 1,2|Duplicates in inverse_rel_attributes|N|This check looks for duplicate values in either the <tt>relationship_attribute</tt> or <tt>inverse_rel_attribute</tt> fields of <tt>inverse_rel_attributes</tt>.  If the duplicate relas have the same inverse values, the autofix can be used to correct the problem.  If not, they must be manually resolved.|0||delete from inverse_rel_attributes where rowid in  (select min(rowid) from inverse_rel_attributes where relationship_attribute in  (select relationship_attribute from inverse_rel_attributes group by relationship_attribute having count(*)>1 union select inverse_rel_attribute from inverse_rel_attributes group by inverse_rel_attribute having count(*)>1) group by relationship_attribute)|
core table semantics|select /*+ PARALLEL(r) */ distinct concept_id_1 as concept_id from relationships r where source like 'NLM%' and concept_id_1=concept_id_2 and tobereleased in ('Y','y') and relationship_name != 'SFO/LFO'|Self-referential NLM% rels|Y|NLM asserted relationships should not be self-referenital (<tt>concept_id_1=concept_id_2</tt>).  This check returns <tt>concept_id</tt>s associated with offending cases.  This check should not be algorithmically fixed, the cases should be reviewed manually by editors using the NLM Rela Editing interface.|0|||
core table semantics|select concept_id_1, concept_id_2 from (select /*+ PARALLEL(r) */ concept_id_1, concept_id_2 from relationships r where relationship_level='C' and concept_id_1 < concept_id_2 union all select /*+ PARALLEL(r) */ concept_id_2, concept_id_1 from relationships r where relationship_level='C' and concept_id_1 > concept_id_2) group by concept_id_1, concept_id_2 having count(*)>1|Multiple C-level relationships|Y|For any pair of concepts in the MID there should not be more than one MTH asserted relationship (level=C).  This check reports both <tt>concept_id_1</tt> and <tt>concept_id_2</tt> fields of any offending cases.  Fixing this check will involve finding duplicate cases, choosing the highest ranking relationship (using <tt>MEME_RANKS.rank_relationships</tt>) and removing all others.  The OpenROAD code that manages relationships should not allow this condition to exist, and therefore violations of this check are rare.|0|||
unique identifier (ui) referential integrity|select concept_id from attributes where attribute_level='C' minus select concept_id from classes|C level attributes minus classes|Y|This query retuns any <tt>concept_id</tt>'s that are C level attributes from the attributes table that do not match to a <tt>concept_id</tt> in the classes table.|0|||
unique identifier (ui) referential integrity|select atom_id_1 from (select atom_id_1 from context_relationships union all select atom_id_2 from context_relationships) minus select atom_id from classes|Rows in CR minus classes|N|This query retuns any <tt>atom_id</tt>'s from the context_relationships table, either atom_id_1 or atom_id_2, that do not match to an <tt>atom_id</tt> in the classes table.|0|||
unique identifier (ui) integrity|select atom_id from (select atom_id from classes union all select atom_id from dead_classes) group by atom_id having count(*)>1|Duplicate atom_id's (C-dead_C)|N|Every <tt>atom_id</tt> must be unique.  This query returns <tt>atom_id</tt>'s from classes and dead_classes that are not unique.|0|||
unique identifier (ui) integrity|select atom_id from (select atom_id from atoms union all select atom_id from dead_atoms) group by atom_id having count(*)>1|Duplicate atom_id's (atoms-dead_atoms)|N|Every <tt>atom_id</tt> must be unique.  This query returns <tt>atom_id</tt>'s from atoms and dead_atoms that are not unique.|0|||
unique identifier (ui) integrity|select concept_id from (select concept_id from concept_status union all select concept_id from dead_concept_status) group by concept_id having count(*)>1|Duplicate concept_id's (CS-dead_CS)|Y|Every <tt>concept_id</tt> must be unique.  This query returns <tt>concept_id</tt>'s from concept_status and dead_concept_status that are not unique.|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(a) */ attribute_id from (select attribute_id from attributes union all select attribute_id from dead_attributes) a group by attribute_id having count(*)>1|Duplicate attribute_id's (A-dead_A)|N|Every <tt>attribute_id</tt> must be unique.  This query returns <tt>attribute_id</tt>'s from attributes and dead_attributes that are not unique.|0|||
rxnorm semantics|select atom_id,concept_id from classes where atom_id in (select atom_id from classes where source='NLM02' and termgroup='NLM02/SCD' and tobereleased in ('Y','y') minus (select atom_id_2 from relationships a, classes b where a.source='NLM02' and relationship_attribute='isa' and relationship_level='S' and atom_id_1 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SCDF' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y') group by atom_id_2 having count(*) = 1))|Normal form without SCDF|Y|Every normal form must be connected to exactly one semantic clinical drug and form.  This check returns cases which are not.|0|||
unique identifier (ui) integrity|select string_id from (select string_id,row_sequence from stringtab union all select string_id,row_sequence from dead_stringtab) group by row_sequence,string_id having count(*)>1|Duplicate string_id's (stringtab-dead_stringtab)|N|Every <tt>string_id</tt> must be unique.  This query returns <tt>string_id</tt>'s from the stringtab and dead_stringtab tables that are not unique.|0|||
rxnorm semantics|select atom_id from classes where source='NLM02' and termgroup='NLM02/SBDF' and tobereleased in ('Y','y') minus (select atom_id_1 from relationships a, classes b where a.source='NLM02' and relationship_attribute='isa' and relationship_level='S' and atom_id_2 = b.atom_id and b.source='NLM02' and b.termgroup='NLM02/SBD' and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y'))|SBDF without branded normal form|Y|Every semantic clinical branded drug and form must be connected to a branded normal form.  This check returns cases which are not.  To fix, click <a href="/cgi-lti-oracle/rxnorm_maintenance.cgi">here</a> and select "Disable Unused Atoms".|0|||
unique identifier (ui) integrity|select relationship_id from (select relationship_id from context_relationships union all select relationship_id from dead_context_relationships) group by relationship_id having count(*)>1|Duplicate relationship_id's (CR-dead_CR)|N|Every <tt>relationship_id</tt> must be unique.  This query returns <tt>relationship_id</tt>'s from context_relationships and dead_context_relationships that are not unique.|0|||
unique identifier (ui) integrity|select a.relationship_id from relationships a, context_relationships b where a.relationship_id=b.relationship_id|Overlapping relationship_id's (R-CR)|N|Every <tt>relationship_id</tt> in the relationships table must have a different value than every <tt>relationship_id</tt> in the context_relationships table.  This query returns <tt>relationship_id</tt>'s that violate this most sacred condition.|0|||
unique identifier (ui) integrity|select a.relationship_id from relationships a, dead_context_relationships b where a.relationship_id=b.relationship_id|Overlapping relationship_id's (R-dead_CR)|N|Every <tt>relationship_id</tt> in the relationships table must have a different value than every <tt>relationship_id</tt> in the dead_context_relationships table.  This query returns <tt>relationship_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(aa) */ atomic_action_id from atomic_actions aa group by atomic_action_id having count(*)>1|Duplicate atomic_action_id's|N|Every <tt>atomic_action_id</tt> must be unique.  This query returns <tt>atomic_action_id</tt>'s from the atomic_actions table that are not unique.|0|||
unique identifier (ui) integrity|select atom_id from (select atom_id from classes union all select atom_id from dead_classes) where atom_id > (select max_id from max_tab where table_name='ATOMS')|atom_id out of range (C-dead_C)|N|An <tt>atom_id</tt> found in classes or dead_classes must never be greater than the <tt>max_id</tt> for atoms in the max_tab table.  This query returns <tt>atom_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select concept_id from (select concept_id from concept_status union all select concept_id from dead_concept_status) where concept_id > (select max_id from max_tab where table_name='CONCEPT_STATUS')|concept_id out of range (CS-dead_CS)|Y|A <tt>concept_id</tt> found in concept_status or dead_concept_status must never be greater than the <tt>max_id</tt> for concept_status in the max_tab table.  This query returns <tt>concept_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select relationship_id from (select relationship_id from relationships union all select relationship_id from dead_relationships) where relationship_id > (select max_id from max_tab where table_name='RELATIONSHIPS')|relationship_id out of range (R-dead_R)|N|A <tt>relationship_id</tt> found in relationships or dead_relationships must never be greater than the <tt>max_id</tt> for relationships in the max_tab table.  This query returns <tt>relatioship_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select attribute_id from (select attribute_id from attributes union all select attribute_id from dead_attributes) where attribute_id > (select max_id from max_tab where table_name='ATTRIBUTES')|attribute_id out of range (A-dead_A)|N|An <tt>attribute_id</tt> found in attributes or dead_attributes must never be greater than the <tt>max_id</tt> for attributes in the max_tab table.  This query returns <tt>attribute_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select molecule_id from molecular_actions where molecule_id > (select max_id from max_tab where table_name='MOLECULAR_ACTIONS')|molecule_id out of range (molecular_actions)|N|A <tt>molecule_id</tt> found in molecular_actions must never be greater than the <tt>max_id</tt> for molecular_actions in the max_tab table.  This query returns <tt>molecule_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select concept_id_1 as concept_id, relationship_id from relationships where rui is null and tobereleased in ('Y','y')|Releasable rel with null RUI|N|Every releasable relationship must have a non-null RUI.  Violations can be fixed by running MEME_SOURCE_PROCESSING.assign_ruis.|0|||
string unique identifier integrity|select norm_string,language from string_ui group by norm_string,language having count(distinct lui)>1|(norm_string,language)-LUI mismatch|N|Every <tt>norm_string</tt>,<tt>language</tt> must have a distinct <tt>LUI</tt> in the <tt>string_ui</tt> table.  This query returns <tt>norm_string</tt>,<tt>language</tt> tuples that violate this condition.|0|||
unique identifier (ui) integrity|select relationship_id from (select relationship_id from relationships union all select relationship_id from dead_relationships) group by relationship_id having count(*)>1|Duplicate relationship_id's (R-dead_R)|N|Every <tt>relationship_id</tt> must be unique.  This query returns <tt>relationship_id</tt>'s from relationships and dead_relationships that are not unique.|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(m) */ molecule_id from molecular_actions m group by molecular_action,molecule_id having count(*)>1|Duplicate molecule_id's|N|Every <tt>molecular_action<tt> must have a unique <tt>molecule_id</tt>.  This query returns <tt>molecule_id</tt>'s from the molecular_actions table that violate this condition.|0|||
unique identifier (ui) integrity|SELECT source_row_id from source_id_map WHERE table_name='C' group by source_row_id having count(*)>1|Duplicate ids in source_id_map (C)|N|Every <tt>source_row_id</tt> in the source_id_map table must be unique.  This query check those rows where the <tt>table_name</tt> field is <tt>C</tt> (Classes) in the source_id_map table, and returns <tt>source_row_id</tt>'s that are not unique.|0|||
unique identifier (ui) integrity|select string_id from (select to_number(substr(attribute_value,20)) as string_id from attributes where attribute_value like '<>Long_Attribute<>:%' union all select to_number(substr(attribute_value,20)) as string_id from dead_attributes where attribute_value like '<>Long_Attribute<>:%') group by string_id having count(*)>1|Duplicate string_ids (A)|N|Every <tt>string_id</tt> must be unique.  This query returns <tt>string_id</tt>'s that are not unique; these values having been exracted from the attribute_value field from both the attributes and dead_attributes tables where the attribute_value field is a <tt>Long_Attribute</tt>.|0|||
unique identifier (ui) integrity|select a.relationship_id from dead_relationships a, context_relationships b where a.relationship_id=b.relationship_id|Overlapping relationship_id's (dead_R-CR)|N|Every <tt>relationship_id</tt> in the dead_relationships table must have a different value than every <tt>relationship_id</tt> in the context_relationships table.  This query returns <tt>relationship_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select atom_id from (select atom_id from atoms union all select atom_id from dead_atoms) where atom_id > (select max_id from max_tab where table_name='ATOMS')|atom_id out of range (atoms-dead_atoms)|N|An <tt>atom_id</tt> found in atoms or dead_atoms must never be greater than the <tt>max_id</tt> for atoms in the max_tab table.  This query returns <tt>atom_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select string_id from (select to_number(substr(attribute_value,20)) as string_id from attributes where attribute_value like '<>Long_Attribute<>:%' union all select to_number(substr(attribute_value,20)) as string_id from dead_attributes where attribute_value like '<>Long_Attribute<>:%') where string_id > (select row_sequence from stringtab where string_id=-1)|string_id out of range (A-dead_A)|N|A <tt>string_id</tt> found in attributes or dead_attributes tables, having been extracted from the <tt>attribute_value</tt> of <tt>Long_Attributes</tt>, must never be greater than the <tt>row_sequence</tt> for a string_id value of -1 in the stringtab table.  This query returns <tt>string_id</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select last_release_cui from (select last_release_cui from classes union all select last_release_cui from dead_classes) where to_number(replace(last_release_cui,'C','')) > (select max_id from max_tab where table_name='CUI')|last_release_cui out of range (C)|N|A <tt>last_release_cui</tt> found in classes or dead_classes must never be greater than the <tt>max_id</tt> for a CUI in the max_tab table.  This query returns <tt>last_release_cui</tt>'s that violate this condition.|0|||
unique identifier (ui) integrity|select relationship_id from (select relationship_id from context_relationships union all select relationship_id from dead_context_relationships) where relationship_id > (select max_id from max_tab where table_name='RELATIONSHIPS')|relationship_id out of range (CR-dead_CR)|N|A <tt>relationship_id</tt> found in context_relationships or dead_context_relationships must never be greater than the <tt>max_id</tt> for relationships in the max_tab table.  This query returns <tt>relatioship_id</tt>'s that violate this condition.|0|||
new src integrities|select a.source,language,character_set,source_family from sims_info a, source_rank b where (a.language is null or a.character_set is null or a.character_set != 'UTF-8' or b.source_family is null) and a.source in (select current_name from source_version)  and a.source=b.source|Source without language/character_set/source_family|N|Every source with atoms must have its language and character_set fields populated.|5|The following are exceptions because they do not have atoms: 
MED03
NCISEER_1999
MBD03
HLREL_1998
NLM-MED||
new src integrities|select source from sims_info where (source_official_name is null or source_short_name is null) and source in (select current_name from source_version) and source in (select source from source_rank where source=normalized_source)|Source without name/short name|N|Every source must have its official name and short name set. If violations show up, try running the "set official name" script off of the <a href="/cgi-lti-oracle/release_maintenance.cgi"> Release Maintenance</a> script.|0|||
core table semantics|select /*+ PARALLEL(cr) */ distinct b.source from context_relationships cr, source_version b  where cr.source = b.current_name and relationship_name = 'PAR' and tobereleased in ('Y','y') group by b.source having  count(distinct decode(nvl(hierarchical_code,'null'),'null',0,1))>1|Inconsistent hierarchical code|N|Sources with contexts should either always use hierarchical codes or never use hierarchical codes.  This check finds sources which sometimes have hierarchical codes among PAR relationships and sometimes don't.  Typically this indicates an error in the way contexts were built.  This check was added to identify an error found in MRCXT during the 2003AC build.  
|3|There are seven sources on the list:<ol><li>AIR</li><li>CST</li><li>MSH</li></ol>||
rxnorm semantics|select atom_id_1,atom_id_2 from relationships where source='NLM02' and relationship_level='S' and tobereleased in ('Y','y') group by atom_id_1,atom_id_2,relationship_attribute having count(*)>1|Duplicate RxNorm relationships|N|Any RxNorm relationship should uniquely define the relationship between two atoms in a graph.  Any cases where there is more than one relationship between two graph atoms is problematic and should be dealt with.   This check finds the atom ids involved in such cases.|0||DECLARE x number;  BEGIN MEME_UTILITY.drop_it('table', 'tjfw_$$');  EXECUTE IMMEDIATE 'create table tjfw_$$ as select min(relationship_id) as row_id from relationships a where a.source=''NLM02'' and a.relationship_level=''S'' and a.tobereleased in (''Y'',''y'') group by atom_id_1, atom_id_2, relationship_attribute having count(*)>1';  x:=MEME_BATCH_ACTIONS.macro_action( action=>'D', id_type=>'R', authority=>'L-JFW', table_name=>'tjfw_$$', work_id=>0, status=>'R');  MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
core table semantics|select concept_id from concept_status where tobereleased in  ('Y','y') and concept_id<1000|Releasable QA concepts|Y|All concepts with concept_ids less than 1000 exist for QA purposes and should not ever be releasable except during validation runs.  This check finds cases of releasable concepts in this range.|0|||
core table semantics|select /*+ PARALLEL(r) */ concept_id_1,concept_id_2 from relationships r where relationship_level='C' and status='R' and (concept_id_1,concept_id_2) in (select concept_id_1,concept_id_2 from relationships where status='D' union select concept_id_2,concept_id_1 from relationships where status='D')|Approved C rel matching demotion|N|Concept level relationships matching demotions (on concept ids) should be unapproved (otherwise the demotion should be gone).  If these cases occur we need to find out where the hole in the logic is that allows it to happen. 

Violations of this check will likely be the result of a bug in one of the molecular actions that deals with relationships (insert rel, merge, split, move, etc).|0||DECLARE x number;   BEGIN  MEME_UTILITY.drop_it('table', 'tjfw_$$');   EXECUTE IMMEDIATE 'create table tjfw_$$ as select relationship_id as row_id from relationships where relationship_level=''C'' and status=''R'' and (concept_id_1,concept_id_2) in (select concept_id_1,concept_id_2 from relationships where status=''D'' union select concept_id_2,concept_id_1 from relationships where status=''D'')';   x:=MEME_BATCH_ACTIONS.macro_action(  action=>'S', id_type=>'R', authority=>'L-JFW',  table_name=>'tjfw_$$', work_id=>0, status=>'R',  new_value=>'N');   MEME_UTILITY.drop_it('table', 'tjfw_$$');   END;|
unique identifier (ui) integrity|select aui from atoms_ui where stripped_source !='DOR' AND stripped_source in (select stripped_source from source_rank where source!=normalized_source minus select stripped_source from source_rank where source=normalized_source)|AUI with bad root source|N|AUIs should be expressed using normalized, root source values, not simply root source values.  This check finds violations. This is a serious and VERY uncommon problem.|0|||
unique identifier (ui) integrity|select * from relationships_ui where root_source in  (select stripped_source from source_rank where source!=normalized_source minus select stripped_source from source_rank where source=normalized_source)|RUI with bad source|N|RUIs should be expressed in terms of normalized stripped source values, not simply root source values.  This check finds violations.  This is a serious but VERY rare problem.|0|||
unique identifier (ui) integrity|select * from attributes_ui where root_source in  (select stripped_source from source_rank where source!=normalized_source minus select stripped_source from source_rank where source=normalized_source)|ATUI with bad source|N|ATUIs should be expressed in terms of normalized, root source values instead of simply root source values.  This check finds violations.  This is a serious but VERY rare problem.|0|||
core table semantics|select /*+ INDEX(a,x_attr_an) */ a.attribute_id  from attributes a  where a.attribute_name='XMAP'    and a.tobereleased in ('Y','y')  minus  (select attribute_id from  (select /*+ INDEX(a,x_attr_an) */ a.attribute_id   from attributes a   where a.attribute_name='XMAP'     and a.tobereleased in ('Y','y')     and a.attribute_value not like '<>Long_Attribute<>:%'     and (a.atom_id, substr(a.attribute_value,instr(a.attribute_value,'~',1,5)+1,             instr(a.attribute_value,'~',1,6)-instr(a.attribute_value,'~',1,5)-1)) in    (select /*+ INDEX(b,x_attr_an) */ b.atom_id, substr(b.attribute_value,1,instr(b.attribute_value,'~')-1)     from attributes b     where b.attribute_name='XMAPTO'       and b.tobereleased in ('Y','y')       and b.attribute_value not like '<>Long_Attribute<>:%')   union all   select /*+ INDEX(a,x_attr_an) */ a.attribute_id   from attributes a   where a.attribute_name='XMAP'       and a.tobereleased in ('Y','y')       and a.attribute_value not like '<>Long_Attribute<>:%'       and (a.atom_id, substr(a.attribute_value,instr(a.attribute_value,'~',1,5)+1,  	  instr(a.attribute_value,'~',1,6)-instr(a.attribute_value,'~',1,5)-1)) in    (select /*+ INDEX(c,x_attr_an) */ c.atom_id, substr(b.text_value,1,instr(b.text_value,'~')-1)     from attributes c, stringtab b     where c.attribute_name='XMAPTO'     and c.tobereleased in ('Y','y')     and c.attribute_value like '<>Long_Attribute<>:%'     and b.string_id = to_number(substr(c.attribute_value,20)))  ) group by attribute_id)|Dangling XMAP (no XMAPTO)|N|Releasable XMAP attributes should be connected to releasable
XMAPTO attributes.  This finds cases that are not.|0|||
core table semantics|select /*+ INDEX(a,x_attr_an) */ attribute_id  from attributes a  where attribute_name='XMAPFROM'    and tobereleased in ('Y','y')    and attribute_value not like '<>Long_Attribute<>:%'  minus  select /*+ INDEX(a,x_attr_an) */ attribute_id  from attributes a  where attribute_name='XMAPFROM'    and tobereleased in ('Y','y')    and attribute_value not like '<>Long_Attribute<>:%'    and (a.atom_id, substr(attribute_value,1,instr(attribute_value,'~')-1)) in   (select /*+ INDEX(a,x_attr_an) */ a.atom_id, substr(attribute_value,instr(attribute_value,'~',1,2)+1,  	    instr(attribute_value,'~',1,3)-instr(attribute_value,'~',1,2)-1)    from attributes a    where attribute_name='XMAP'      and tobereleased in ('Y','y')      and attribute_value not like '<>Long_Attribute<>:%')|Dangling XMAPFROM|N|Releasable XMAPFROM attributes should be connected to releasable XMAP attributes.  This finds cases that are not.|0||DECLARE x number; BEGIN MEME_UTILITY.drop_it('table', 'tjfw_$$'); EXECUTE IMMEDIATE 'create table tjfw_$$ as select /*+ INDEX(a,x_attr_an) */ attribute_id from attributes a where attribute_name=''XMAPFROM''  and tobereleased in (''Y'',''y'')  and attribute_value not like ''<>Long_Attribute<>:%'' minus select /*+ INDEX(a,x_attr_an) */ attribute_id from attributes a where attribute_name=''XMAPFROM''  and tobereleased in (''Y'',''y'')  and attribute_value not like ''<>Long_Attribute<>:%''  and (a.atom_id, substr(attribute_value,1,instr(attribute_value,''~'')-1)) in  (select /*+ INDEX(a,x_attr_an) */ a.atom_id, substr(attribute_value,instr(attribute_value,''~'',1,2)+1, 	  instr(attribute_value,''~'',1,3)-instr(attribute_value,''~'',1,2)-1)  from attributes a  where attribute_name=''XMAP''   and tobereleased in (''Y'',''y'')   and attribute_value not like ''<>Long_Attribute<>:%'')';  x:=MEME_BATCH_ACTIONS.macro_action(  action=>'T', id_type=>'A', authority=>'L-JFW',  table_name=>'tjfw_$$', work_id=>0, status=>'R',  new_value=>'N');  MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
other referential integrities|select /*+ parallel(cr) */ source from context_relationships cr where relationship_name='PAR' and release_mode='11'   and tobereleased in ('Y','y') minus select source from sims_info where context_type not like '%NOSIB%'|Bad release_mode in context_relationships|N|Sources without siblings must not have a release_mode value of '11' in context_relationships, otherwise the MRCXT building code will attempt to create them.
|0|||
core table semantics|select c.source from classes c, sims_info s    where c.source = s.source    and s.language is null  and c.tobereleased in ('Y','y') union  select f.source from foreign_classes f, sims_info s    where f.source = s.source    and s.language is null and f.tobereleased in ('Y','y')|Atom with null language value|N|Sources in classes/foreign_classes must have a non-null language value in sims_info.|0|||
core table semantics|select /*+ PARALLEL(a) */ attribute_value from attributes a where attribute_value not like '%<>Long_Attribute<>:%' and tobereleased in ('Y','y') group by attribute_value having count(distinct hashcode)>1|Attribute value with multiple hashcodes|N|There should be a one-one mapping between attribute_value and hashcode.|0|||
core table semantics|select /*+ PARALLEL(a) */ hashcode from attributes a    where tobereleased in ('Y','y')    and attribute_value not like '<>Long_Attribute<>:%'    group by hashcode having count(distinct attribute_value)>1|Hashcode with multiple attribute values|N|There should be a one-one mapping between attribute_value and hashcode.
|0|||
unique identifier (ui) integrity|select /*+ PARALLEL(r) */ distinct r.source    from relationships r, sims_info s    where r.source = s.source    and source_rui is not null    and rel_directionality_flag!='Y'  union  select /*+ PARALLEL(cr) */ distinct cr.source    from context_relationships cr, sims_info s    where cr.source = s.source    and source_rui is not null    and rel_directionality_flag!='Y'|Source rui without rel directionality|N|Sources with non-null source_rui must have rel_directionality_flag='Y' in sims_info.|0|||
unique identifier (ui) integrity|select aui from classes    where tobereleased in ('Y','y')    and source != 'NLM02'  and termgroup !='MTH/PN'  group by aui having count(distinct sui||source||tty||code||source_aui||source_cui||source_dui||concept_id)>1|Non-unique AUI (!NLM02)|N|No two releasable classes should have the same AUI.|0|||
core table semantics|select max(atom_id) atom_id, upper(atom_name) from atoms  where atom_id in (select atom_id from classes where source='MTH' and  tty in ('MM','TM') and tobereleased in ('Y','y'))  group by upper(atom_name) having count(*)>1|MTH/MM or MTH/TM with duplicate string|N|MTH/MM and MTH/TM strings should be unique.  If mthtm.pl script is creating this problem, fix the script.|0|Reoccurring issue with MTH/MM.|BEGIN    meme_utility.drop_it('table','tbac_$$');    execute immediate 'create table tbac_$$ as select max(atom_id) row_id from atoms  where atom_id in (select atom_id from classes where source=''MTH'' and  tty in (''MM'',''TM'') and tobereleased in (''Y'',''y''))  group by upper(atom_name) having count(*)>1';     dbms_output.put_line(meme_batch_actions.batch_action(      action=>'D', id_type=>'C', authority=>'MTH',      table_name=>'tbac_$$', work_id=>0));  END;|
new src integrities|select current_name,previous_name from source_version a, source_rank b where current_name=b.source and previous_name=b.normalized_source|Normalized source is previous version|N|The normalized_source name in source_rank should not be set to the previous version of a source.  It should most likely be set to the current version.|0|||
core table semantics|select /*+ PARALLEL(b) */      b.atom_id,a.relationship_id,a.source as s1,b.source as s2    from relationships a, classes b    where relationship_level='S' and a.tobereleased in ('Y','y')      and a.source in (select current_name from source_version)      and b.tobereleased in ('N','n')     and a.atom_id_1 = b.atom_id      and a.source not like 'E-%'    union    select /*+ PARALLEL(a) */      b.atom_id,a.relationship_id,a.source as s1,b.source as s2    from relationships a, classes b    where relationship_level='S' and a.tobereleased in ('Y','y')      and a.source in (select current_name from source_version)      and b.tobereleased in ('N','n')      and a.atom_id_2 = b.atom_id      and a.source not like 'E-%'|Current ver relationship connected to old ver atom|N|Current version relationships should be attached to current
version atoms.  This check finds cases where current version
relationships are instead attached to old version atoms.  

The auto-fix will handle cases with "mappable" SG types that are connected to the wrong version of a source due to a recent update of that source.   If this is the case, try using the auto fix.

<p>Otherwise, fix this problem with code like the following:
<blockquote><pre>
create table tkao as
select /*+ PARALLEL(b) */ b.atom_id, a.relationship_id, a.source as s1, b.source as s2
from relationships a, classes b 
where relationship_level='S' and a.tobereleased in ('Y','y') 
and a.source in (select current_name from source_version) 
and b.tobereleased in ('n','N')
and a.atom_id_1 = b.atom_id and a.source not like 'E-%' 
union 
select /*+ PARALLEL(a) */ b.atom_id,a.relationship_id,a.source as s1,b.source as s2 
from relationships a, classes b 
where relationship_level='S' and a.tobereleased in ('Y','y') 
and a.source in (select current_name from source_version) 
and b.tobereleased in ('N','n')
and a.atom_id_2 = b.atom_id and a.source not like 'E-%';

drop table tkao2;
create table tkao2 as
select * from relationships where relationship_id in 
(select relationship_id from tkao);

update tkao2 set atom_id_1=0, atom_id_2=0,
 concept_id_1=0, concept_id_2=0, rui = null;
commit;

create index x_tkao2 on tkao2(relationship_id) compute statistics parallel;

exec meme_source_processing.map_sg_fields('tkao2','Y','Y','Y');

update tkao2 a set sg_id_1 =
 (select aui from classes where atom_id=atom_id_1)
where sg_type_1='AUI';
update tkao2 a set sg_id_2 =
 (select aui from classes where atom_id=atom_id_2)
where sg_type_2='AUI';


exec meme_source_processing.assign_ruis('tkao2','MTH',0);

delete from relationships where relationship_id in
(select relationship_id from tkao2);

insert into relationships select * from tkao2;

commit;
</pre></blockquote>
|0||BEGIN MEME_SOURCE_PROCESSING.map_sg_data('MTH',0); END;|
core table semantics|select /*+ parallel(cr) */ relationship_id, relationship_attribute, relationship_name from context_relationships cr where relationship_name || relationship_attribute in ('PARisa','SIBinverse_isa','PARbranch_of','SIBhas_branch') and tobereleased in ('Y','y')|Inverted context relationship attributes|N|When we insert context relationships, we invert the rela values in the contexts.src file for PAR relationships but not for SIB. If the code to do this is run twice, it causes the PAR rels to have inverted relas.  This check finds such cases so that they can be repaired.|0|||
core table semantics|select /*+ INDEX(a,x_attr_an) */ attribute_id  from attributes a  where attribute_name='XMAP'    and tobereleased in ('Y','y')    and attribute_value not like '<>Long_Attribute<>:%'  minus  select /*+ INDEX(a,x_attr_an) */ attribute_id  from attributes a  where attribute_name='XMAP'    and tobereleased in ('Y','y')    and attribute_value not like '<>Long_Attribute<>:%'    and (a.atom_id, substr(attribute_value,instr(attribute_value,'~',1,2)+1,  	instr(attribute_value,'~',1,3)-instr(attribute_value,'~',1,2)-1)) in   (select /*+ INDEX(c,x_attr_an) */ c.atom_id, substr(attribute_value,1,instr(attribute_value,'~')-1)    from attributes c  where attribute_name='XMAPFROM'      and tobereleased in ('Y','y')      and attribute_value not like '<>Long_Attribute<>:%')|Dangling XMAP (no XMAPFROM)|N|Releasable XMAP attributes should be connected to releasable XMAPFROM attributes.  This finds cases that are not.|0||DECLARE x number; BEGIN MEME_UTILITY.drop_it('table', 'tjfw_$$'); EXECUTE IMMEDIATE 'create table tjfw_$$ as select /*+ INDEX(a,x_attr_an) */ attribute_id as row_id from attributes a  where attribute_name=''XMAP''    and tobereleased in (''Y'',''y'')    and attribute_value not like ''<>Long_Attribute<>:%''  minus  select /*+ INDEX(a,x_attr_an) */ attribute_id from attributes a  where attribute_name=''XMAP''    and tobereleased in (''Y'',''y'')    and attribute_value not like ''<>Long_Attribute<>:%''    and (a.atom_id, substr(attribute_value,instr(attribute_value,''~'',1,2)+1,  	instr(attribute_value,''~'',1,3)-instr(attribute_value,''~'',1,2)-1)) in   (select /*+ INDEX(a,x_attr_an) */ a.atom_id, substr(attribute_value,1,instr(attribute_value,''~'')-1)    from attributes a    where attribute_name=''XMAPFROM''      and tobereleased in (''Y'',''y'')      and attribute_value not like ''<>Long_Attribute<>:%'')';  x:=MEME_BATCH_ACTIONS.macro_action(  action=>'T', id_type=>'A', authority=>'L-JFW',  table_name=>'tjfw_$$', work_id=>0, status=>'R',  new_value=>'N');  MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
core table semantics|select concept_id, atom_id from classes where termgroup IN ('MTH/PT','MTH/MM') AND code = 'NOCODE' and tobereleased in ('Y','y')|NOCODE MTH/{PT,MM} atoms|Y|MTH/MM and MTH/PT atoms are inserted algorithmically and assigned U-codes (codes beginning with the letter U and followed by six digits).  Any atoms with these termgroups and a NOCODE code indicate a violation.  Violations of this check indicate a serious problem in the code that manages these atoms.  Fixing it involves finding the highest U-code for each termgroup and assigning new code values for those atoms with NOCODE codes.  Make sure to use <tt>MEME_BATCH_ACTIONS.macro_action</tt> so that the data change is properly logged.|0|||
core table semantics|select /*+ PARALLEL(r) */ concept_id_1 as concept_id, relationship_id from relationships r where relationship_level='C' and concept_id_1=concept_id_2|Self-referential C level relationships|Y|MTH asserted relationships should never be self-referential (<tt>concept_id_1=concept_id_2</tt>).  This check returns <tt>relationship_id</tt>s of offending rows.  These rows should be removed using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select /*+ PARALLEL(a) FULL(a) */ concept_id, attribute_id from attributes a where attribute_name ='CONTEXT' and upper(tobereleased||attribute_level||status) != 'NSR'|bad CONTEXT attributes|Y|CONTEXT attributes must be unreleasable and have a level of S and be approved.  This check returns <tt>concept_id</tt> and <tt>attribute_id</tt>s of rows offending any of these conditions.  To fix the problem, you must identify incorrect <tt>tobereleased</tt>, <tt>attribute_level</tt>, and <tt>status</tt> values and correct them using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select concept_id, attribute_id from attributes where attribute_name='LEXICAL_TAG' and attribute_value != 'TRD' and (tobereleased NOT IN ('n','N') OR attribute_level !='S')|bad LEXICAL_TAG (non-TRD) attributes|Y|Non TRD LEXICAL_TAG attributes must be unreleasable and have a level of S.  This query returns <tt>concept_id</tt> and <tt>attribute_id</tt>s of offending cases.  To fix this problem, identify those rows and change either the offending <tt>tobereleased</tt> or <tt>attribute_level</tt> values using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select /*+ PARALLEL(a) */ concept_id, attribute_id from attributes a where attribute_name='SEMANTIC_TYPE' and (tobereleased NOT IN ('y','Y') OR attribute_level !='C' OR sg_type!='CONCEPT_ID')|bad SEMANTIC_TYPE attributes|Y|SEMANTIC_TYPE attributes must be releasable, have a level of C, and have a sg_type of CONCEPT_ID.  This query returns <tt>concept_id</tt> and <tt>attribute_id</tt>s of offending cases.  To fix this problem, identify those rows and change either the offending <tt>tobereleased</tt> or <tt>attribute_level</tt> values using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|0|||
core table semantics|select count(*),source,relationship_level, status, tobereleased from relationships r where relationship_name='SFO/LFO' and (relationship_level !='S' OR status !='R' or tobereleased='n') and source in (select current_name from source_version) group by source,relationship_level, status, tobereleased|bad SFO/LFO relationships|Y|SFO/LFO relationships must have a relationship level of S and have a status of R and should be releasable.  This query returns the list of sources containing offending cases.  To fix this problem, identify those rows and change either the offending <tt>relationship_level</tt> or <tt>status</tt> or <tt>tobereleased</tt> values using <tt>MEME_BATCH_ACTIONS.macro_action</tt>.|5|Current version of HCPCS has SFO/LFO to AB atoms.  This includes HCPT, CDT, and HCDT now also. MSHSPA2007 relationship should go away after the MSH update.||
core table semantics|select /*+ PARALLEL(c) */ concept_id from classes c where termgroup='MTH/PN' and tobereleased in ('Y','y') group by concept_id having count(*)>1|~ concepts with multiple MTH/PN atoms|Y|Concepts should have at most one releasable MTH/PN atom. This query finds  <tt>concept_id</tt>'s that have more than one MTH/PN atom.  To fix this problem, choose the best MTH/PN atom and make all others unreleasable.  The helper frame for adding PN atoms automatically makes existing PN atoms in a concept unreleasable so violations of this check should be rare.|0|||
core table semantics|select /*+ PARALLEL(a) */ attribute_id from attributes a where attribute_level='S' and status !='R' and source not like 'E-%'|bad source level attributes|N|All source level attributes must be reviewed (status=R) unless the source is an editors initials, eg. E-BAC.  This query returns <tt>attribute_id</tt>'s where this condition is not held.|0|||
core table semantics|select /*+ PARALLEL(r) */ source, relationship_id from relationships r where relationship_level='C' and tobereleased NOT IN ('y','Y') and source!='NLM03' and relationship_name not in ('BRT','BNT','BBT')|Unreleasable concept level relationships|Y|Generally, concept level relationships must be releasable.  This query returns <tt>source</tt> and <tt>relationship_id</tt>'s which are concept level and yet are not releasable.  

One exception to this rule is bequeathal relationships as well as XR relationships which are not releasable.  In the future, bequeathal relationships will be maintained in a manner separate from other relationships and this exception will no longer be valid.|0|||
other referential integrities|select /*+ PARALLEL(a) */ attribute_id from attributes a where (attribute_level, status) NOT in (select level_value,status from level_status_rank where table_name='A') or released NOT IN ('A','N') or suppressible NOT IN (select suppressible from suppressible_rank) or tobereleased NOT IN (select tobereleased from tobereleased_rank)|Invalid fields (A)|N|The combination of status and level for every attribute must appear in the <tt>level_status_rank</tt> table.  This query returns <tt>attribute_id</tt>'s where the combinations of <tt>status</tt> and <tt>attribute_level</tt> from the attributes table do not appear.  This constraint is checked when data is added so violations should be exceedingly rare.  If they do occur, the values in attributes should be made legal.|0|||
other referential integrities|select /*+ PARALLEL(r) */ relationship_id from relationships r where (status,relationship_level) NOT IN (select status,level_value from level_status_rank where table_name='R')|Invalid level,status fields (R)|N|The combination of status and level for an atom is ranked in the table level_status_rank.  This query returns <tt>relationship_id</tt>'s where the combinations of <tt>status</tt> and <tt>relationship_level</tt> from the relationships table are not ranked in the table level_status_rank.|0|||
other referential integrities|select /*+ PARALLEL(cr) */ relationship_attribute from context_relationships cr where tobereleased in ('Y','y') minus (select relationship_attribute from inverse_rel_attributes)|Invalid relationship_attribute (CR)|N|Every <tt>relationship_attribute</tt> in the context_relationships table must have the same <tt>relationship_attribute</tt> in the inverse_rel_attributes table.  This query returns <tt>relationship_id</tt>'s where a <tt>relationship_attribute</tt> from the table context_relationships is not found in the inverse_rel_attributes table.|0|||
other referential integrities|select /*+ PARALLEL(cr) */ relationship_id from context_relationships cr where (relationship_level,status) NOT IN (select level_value,status from level_status_rank b where table_name='R')|Invalid level,status fields (CR)|N|The combination of status and level for an atom is ranked in the table level_status_rank.  This query returns <tt>relationship_id</tt>'s where the combinations of <tt>status</tt> and <tt>relationship_level</tt> from the context_relationships table are not ranked in the table level_status_rank.|0|||
core table semantics|select /*+ PARALLEL(b) */      b.atom_id,a.relationship_id,a.source as s1,b.source as s2    from context_relationships a, classes b    where relationship_level='S' and a.tobereleased in ('Y','y')      and a.source in (select current_name from source_version)      and b.tobereleased in ('N','n')     and a.atom_id_1 = b.atom_id      and a.source not like 'E-%'    union    select /*+ PARALLEL(a) */      b.atom_id,a.relationship_id,a.source as s1,b.source as s2    from context_relationships a, classes b    where relationship_level='S' and a.tobereleased in ('Y','y')      and a.source in (select current_name from source_version)      and b.tobereleased in ('N','n')      and a.atom_id_2 = b.atom_id      and a.source not like 'E-%'|Current ver context rels connected to old ver atom|N|Current version context relationships should be attached to current
version atoms.  This check finds cases where current version
relationships are instead attached to old version atoms.  

The auto-fix will handle cases with "mappable" SG types that are connected to the wrong version of a source due to a recent update of that source.   If this is the case, try using the auto fix.



<p>Otherwise, fix this problem with code like the following:
<blockquote><pre>
create table tjfw as
select /*+ PARALLEL(b) */ b.atom_id, a.relationship_id, a.source as s1, b.source as s2
from context_relationships a, classes b 
where relationship_level='S' and a.tobereleased in ('Y','y') 
and a.source in (select current_name from source_version) 
and b.source not in (select current_name from source_version) 
and a.atom_id_1 = b.atom_id and a.source not like 'E-%' 
union 
select /*+ PARALLEL(a) */ b.atom_id,a.relationship_id,a.source as s1,b.source as s2 
from context_relationships a, classes b 
where relationship_level='S' and a.tobereleased in ('Y','y') 
and a.source in (select current_name from source_version) 
and b.source not in (select nvl(current_name,'null') from source_version) 
and a.atom_id_2 = b.atom_id and a.source not like 'E-%';

drop table tjfw2;
create table tjfw2 as
select * from context_relationships where relationship_id in 
(select relationship_id from tjfw);

update tjfw2 set atom_id_1=0, atom_id_2=0,
 concept_id_1=0, concept_id_2=0, rui = null;
commit;

create index x_tjfw2 on tjfw2(relationship_id) compute statistics parallel;

exec meme_source_processing.map_sg_fields('tjfw2','Y','Y','Y');

update tjfw2 a set sg_id_1 =
 (select aui from classes where atom_id=atom_id_1)
where sg_type_1='AUI';
update tjfw2 a set sg_id_2 =
 (select aui from classes where atom_id=atom_id_2)
where sg_type_2='AUI';


exec meme_source_processing.assign_ruis('tjfw2','MTH',0);

delete from context_relationships where relationship_id in
(select relationship_id from tjfw2);

insert into context_relationships select * from tjfw2;

commit;
</pre></blockquote>
|0|||
core table semantics|select distinct c.source from classes a, sims_info b, source_version c where a.source = c.current_name and a.code = 'NOCODE' and b.source = c.current_name and b.insert_meta_version is null and c.previous_name is not null minus (select distinct c.source from classes a, sims_info b, source_version c where c.previous_name = a.source and b.source = c.current_name and b.insert_meta_version is null and c.previous_name is not null and a.code = 'NOCODE' union select distinct c.source from classes a, sims_info b, source_version c where c.current_name = a.source and c.previous_name is not null and b.source = c.current_name and b.insert_meta_version is null and a.insertion_date < (select min(timestamp) from molecular_actions) and a.code = 'NOCODE')|Updated source now with CODE=NOCODE|N|Updated source should not change from NOCODE to CODE|0|||
core table semantics|select distinct a.source from source_version a, classes b where a.current_name = b.source and suppressible = 'E'|Unexpected source with suppress = E|N|Sources without suppressible of E should not change after an update|20|PDQ
PPAC
CSP
SNMI
ICPC2EENG
MTH
RCD
UWDA
ICD10AMAE
NCBI
MDR
CCPSS
ICPC2P
DXP
ICD10AM
NDFRT
OMS
SNM
CST
BI||
core table semantics|select distinct a.source from source_version a, classes b where a.current_name = b.source and suppressible = 'O'|Unexpected source with suppress = O|N|Sources without suppressible of O should not change after an update|24|PDQ
MDRGER
MDRDUT
RCD
NCI
LNC
MDRFRE
RCDSY
MDRITA
HL7V3.0
SNOMEDCT
MDRPOR
MDRJPN
HCPCS
HCPT
MDR
MDRSPA
RCDAE
ICPC2P
RXNORM
HCDT
RCDSA
CDT
GO||
core table semantics|select distinct a.source from source_version a, relationships b where a.current_name = b.source and suppressible = 'Y'|Unexpected source with suppressible relationships|N|Sources without suppressible relationships should not change after an update|0|||
core table semantics|select distinct a.source from source_version a, attributes b where a.current_name = b.source and suppressible = 'Y'|Unexpected source with suppressible relationships|N|Sources without attributes should not change after an update|0|||
core table semantics|select distinct a.source from source_version a, context_relationships b where a.current_name = b.source and suppressible = 'Y'|Unexpected source with suppressible relationships|N|Sources without context_relationships should not change after an update|0|||
core table semantics|select count(*),bin_name from meow.EMS3_QABINS where bin_name in ('missing_sty','demotions','msh_c_orphan','msh_d_orphan','msh_q_orphan','sfo_lfo','nh_sty','separated_pm','multiple_pn','pn_pn_ambig','ambig_pn','msh_mrg','msh_sep','msh_n1') group by bin_name|~Required Editing Bins|N|These bins should be edited down to zero before the release|0|||
other referential integrities|select count(*) ct,source from foreign_classes where tobereleased in ('Y','y') and eng_atom_id in (select atom_id from classes where tobereleased in ('N','n') and language='ENG') group by source|Current translation connected to old source|N|Every releasable translation atom should be connected to a releasable english atom.   To fix violations, try this first:
<pre>
#
# Set these params
#
set db=cheek_midp
set user=`$MIDSVS_HOME/bin/get-oracle-pwd.pl -d $db`
set source_list="'CPT01SP','DMDUMD_1996'"

#################################################################
# 1. Map sources across safe-replacement facts
#    - Edit source list
#    - Report to MRD
#################################################################

$ORACLE_HOME/bin/sqlplus -s $user@$db &lt;&lt;EOF
    set serveroutput on size 100000
    WHENEVER SQLERROR EXIT -1
    alter session set sort_area_size=100000000;
    alter session set hash_area_size=100000000;

    exec MEME_UTILITY.drop_it('table','tbac_$$');
    CREATE TABLE tbac_$$ AS
    SELECT DISTINCT old_atom_id, new_atom_id, b.source
    FROM mom_safe_replacement a, foreign_classes b
    WHERE eng_atom_id = old_atom_id
      AND old_atom_id != new_atom_id
      AND b.source in ($source_list)
      AND a.source in (select current_name from source_version)
      AND (a.rank,old_atom_id) in
        (SELECT max(rank),old_atom_id FROM mom_safe_replacement
         GROUP BY old_atom_id,source);

    exec MEME_UTILITY.drop_it('index','x_tbac');
    CREATE INDEX x_tbac ON tbac_$$(old_atom_id,source)
    COMPUTE STATISTICS PARALLEL;

    UPDATE foreign_classes a
    SET eng_atom_id = (SELECT new_atom_id FROM tbac_$$ b
                       WHERE eng_atom_id = old_atom_id
                        AND a.source = b.source)
    WHERE (eng_atom_id,source) IN (SELECT old_atom_id,source FROM tbac_$$);

    exec MEME_UTILITY.put_message('Finished atom_id Update');

    COMMIT;

    UPDATE foreign_classes a
    SET eng_aui =
     (SELECT aui FROM classes b
      WHERE eng_atom_id = b.atom_id)
    WHERE (eng_atom_id,source) IN
      (SELECT new_atom_id,source FROM tbac_$$);

    exec MEME_UTILITY.put_message(sql%rowcount || ' rows updated.');
    exec MEME_UTILITY.put_message('Finished AUI Update');

    COMMIT;

    exec MEME_UTILITY.put_message('Done.');
EOF
if($status != 0) then
    echo "Error"
    exit 1
endif
</pre>

This should be run before using the autofix.  Any remaining entries should have a violation count under 100.  When a translation source is mapped to a new version of the english source, those transation atoms that cannot be mapped should be made unreleasable.|0||update foreign_classes set tobereleased='n' where tobereleased in ('Y','y') and eng_atom_id in (select atom_id from classes where tobereleased in ('N','n') and language='ENG')|
unique identifier (ui) integrity|select rui, relationship_level, relationship_name,     relationship_attribute,   sg_id_1, sg_id_2, c.stripped_source, source_rui  from relationships a, source_rank b, source_rank c  where a.relationship_level = 'S' and a.source = b.source     and b.normalized_source = c.source    and tobereleased in ('Y','y')  minus  select rui, relationship_level, relationship_name, relationship_attribute,   sg_id_1, sg_id_2, root_source, source_rui from relationships_ui r|Bad RUI (S rels - relationships_ui)|N|Finds cases where source level relationships have incorrect RUI assignments.  Violations should be rare.|0|||
other referential integrities|select count(*) ct, source,source_of_label from relationships  where relationship_level='S' and tobereleased in ('Y','y')  and source != source_of_label  group by source, source_of_label  union  select count(*) ct, source,source_of_label from context_relationships  where relationship_level='S' and tobereleased in ('Y','y')  and source != source_of_label  group by source, source_of_label|Rels with source not equal to source_of_label|N|The value of source should be equal to the value of source_of_label in both relationships and context_relationships.|0|||
other referential integrities|select key_qualifier,value from meme_properties where key = 'expanded_form'  group by key_qualifier,value  having count(*) > 1|Duplicate expanded_form|N|Expanded_form in meme_properties should not be duplicated.  Fix these using the <a href="/webapps-meme/meme/controller?state=MRDOCEditor">MRDOC Editor</a>.|0|||
core table semantics|SELECT /*+ PARALLEL(a) */ attribute_id  FROM attributes a  WHERE source NOT IN (SELECT current_name FROM source_version)  AND tobereleased IN ('Y','y')|Releasable old version atts|N|Non-current version attributes should be tbr=n.|0||DECLARE x number;  BEGIN   MEME_UTILITY.drop_it('table', 'tjfw_$$');   EXECUTE IMMEDIATE   'CREATE TABLE tjfw_$$ AS SELECT /*+ PARALLEL(a) */ attribute_id as row_id   FROM attributes a   WHERE source NOT IN (SELECT current_name FROM source_version) AND tobereleased IN (''Y'',''y'')'; x:=MEME_BATCH_ACTIONS.macro_action( action=>'T', id_type=>'A', authority=>'L-JFW', table_name=>'tjfw_$$', work_id=>0, status=>'R', new_value=>'n'); MEME_UTILITY.drop_it('table', 'tjfw_$$');  END;|
source specific integrities|select concept_id,atom_id from classes where source like 'MSH%' and source_dui != code|MSH code does not match SDUI|Y|In the past, some MSH atoms had code != SDUI.  this should never be true.|0|||
new src integrities|WITH rht AS (SELECT a.atom_id, a.code, b.current_name      FROM classes a, source_version b      WHERE a.source='SRC' and a.tty='RHT' and a.tobereleased in ('Y','y')      and substr(a.code,3) = b.source)  SELECT atom_id, code  FROM rht  WHERE current_name IN    (SELECT current_name FROM rht     MINUS     SELECT source FROM context_relationships     WHERE tobereleased in ('Y','y'))|Releasable SRC/RHT without releasable cxt rels|N|There should not be any releasable SRC/RHT atoms whose corresponding current version SAB do not have context relationships.|0||DECLARE x number;  BEGIN   MEME_UTILITY.drop_it('table', 'tjfw_$$');   EXECUTE IMMEDIATE   'CREATE TABLE tjfw_$$ AS   WITH rht AS (SELECT a.atom_id, a.code, b.current_name     FROM classes a, source_version b     WHERE a.source=''SRC'' and a.tty=''RHT'' and a.tobereleased in (''Y'',''y'')     and substr(a.code,3) = b.source) SELECT atom_id as row_id, code FROM rht WHERE current_name IN   (SELECT current_name FROM rht    MINUS    SELECT source FROM context_relationships    WHERE tobereleased in (''Y'',''y''))'; x:=MEME_BATCH_ACTIONS.macro_action( action=>'T', id_type=>'C', authority=>'L-JFW', table_name=>'tjfw_$$', work_id=>0, status=>'R', new_value=>'n'); MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
other referential integrities|select content_view_id from content_views minus  (select content_view_id from content_views a, content_view_members b    where BITAND(b.code,a.content_view_code)= a.content_view_code)  |Empty content view|N|Content views should have members represented in the content_view_members table.|0|||
core table semantics|select distinct b.source, a.tty from termgroup_rank a, source_version b   where suppressible='N' and termgroup in  (select termgroup from classes where suppressible='O' and tobereleased in ('Y','y'))  and substr(termgroup,1,instr(termgroup, '/')-1) = current_name|Non-suppressible Obsolete Term Type|N|A termgroup whose atoms have O suppressibility should not have a tty with N suppressibility.|7|RXNORM/SBDF<br>
RXNORM/SCDC<br>
RXNORM/SCDF<br>
RXNORM/SBDC<br>
RXNORM/SBD<br>
RXNORM/SCD<br>
RXNORM/SY||
other referential integrities|select concept_id,preferred_atom_id from concept_status minus select concept_id,atom_id from classes|Illegal preferred name|N|There should be no preferred_atom_id in concept_status that does not appear in the same concept in classes.|0||begin meme_ranks.set_preference; end;|
core table semantics|select relationship_id, b.concept_id from relationships a, classes b  where a.concept_id_1 = b.concept_id  and a.relationship_name != 'XR'  and a.relationship_level='C'  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and b.tty='XM'  union  select relationship_id, b.concept_id from relationships a, classes b  where a.concept_id_2 = b.concept_id  and a.relationship_name != 'XR'  and a.relationship_level='C'  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and b.tty='XM'|Mapping concepts with non-XR rels|N|Mapping concepts (SAB/XM) should not have non-XR relationships.  If editors have added any such relationships, they should be converted to XR.|0||DECLARE x number;  BEGIN  MEME_UTILITY.drop_it('table', 'tjfw_$$'); EXECUTE IMMEDIATE 'create table tjfw_$$ as select relationship_id as row_id, relationship_name as old_value, relationship_name as new_value from (select relationship_id,relationship_name from relationships a, classes b where a.concept_id_1 = b.concept_id and a.relationship_name != ''XR'' and a.relationship_level=''C'' and a.tobereleased in (''Y'',''y'') and b.tobereleased in (''Y'',''y'') and b.tty=''XM'' union select relationship_id,relationship_name from relationships a, classes b where a.concept_id_2 = b.concept_id and a.relationship_name != ''XR'' and a.relationship_level=''C'' and a.tobereleased in (''Y'',''y'') and b.tobereleased in (''Y'',''y'') and b.tty=''XM'')'; EXECUTE IMMEDIATE 'update tjfw_$$ set new_value=''XR'''; x:=MEME_BATCH_ACTIONS.macro_action(action=>'CF', id_type=>'R', authority=> 'L-JFW', table_name=>'tjfw_$$', work_id=>0, status=>'R', action_field=>'relationship_name'); MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
new src integrities|select tty from termgroup_rank minus select value from meme_properties where key='tty_class'|TTY values without tty_class assignments|N|All TTY values in termgroup_rank must have a tty_class entry in meme_properties.|0|||
core table semantics|SELECT attribute_id, source FROM attributes WHERE attribute_name='XMAP'  AND SUBSTR(attribute_value, instr(attribute_value, '~', 1, 3) + 1, (INSTR(attribute_value, '~', 1, 4) -  INSTR(attribute_value, '~', 1, 3)) -1 ) IS NULL|Null REL in XMAP attribute value|N|MRMAP entries should not have null REL values.  The REL subfield in the XMAP attribute values that form them should not be null.|0|||
new src integrities|select source from sims_info where NVL(rel_directionality_flag,'Y')!='Y'|Invalid rel_directionality_flag in sims_info|N|The rel_directionality_flag in sims_info should always be either 'Y' or null.|0||update sims_info set rel_directionality_flag=null where source in (select source from sims_info where NVL(rel_directionality_flag,'Y')!='Y')|
core table semantics|select /*+ INDEX(a,x_attr_an) */ attribute_id  from attributes a  where attribute_name='XMAPTO'    and tobereleased in ('Y','y')  minus  (select attribute_id from  (select /*+ INDEX(a,x_attr_an) */ attribute_id   from attributes a   where attribute_name='XMAPTO'     and tobereleased in ('Y','y')     and attribute_value not like '<>Long_Attribute<>:%'     and (a.atom_id, substr(attribute_value,1,instr(attribute_value,'~')-1)) in    (select /*+ INDEX(a,x_attr_an) */ a.atom_id, substr(attribute_value,instr(attribute_value,'~',1,5)+1,   	    instr(attribute_value,'~',1,6)-instr(attribute_value,'~',1,5)-1)     from attributes a     where attribute_name='XMAP'       and tobereleased in ('Y','y')       and attribute_value not like '<>Long_Attribute<>:%')   union all   select /*+ INDEX(a,x_attr_an) */ attribute_id   from attributes a, stringtab b   where attribute_name='XMAPTO'     and tobereleased in ('Y','y')     and attribute_value like '<>Long_Attribute<>:%'     and string_id = to_number(substr(attribute_value,20))     and (a.atom_id, substr(b.text_value,1,instr(b.text_value,'~')-1)) in        (select /*+ INDEX(a,x_attr_an) */ a.atom_id,substr(attribute_value,instr(attribute_value,'~',1,5)+1,  	    instr(attribute_value,'~',1,6)-instr(attribute_value,'~',1,5)-1)         from attributes a         where attribute_name='XMAP'           and tobereleased in ('Y','y')           and attribute_value not like '<>Long_Attribute<>:%'))   group by attribute_id)|Dangling XMAPTO|N|Releasable XMAPTO attributes should be connected to releasable
XMAP attributes.  This finds cases that are not.|0||DECLARE x number; BEGIN MEME_UTILITY.drop_it('table', 'tjfw_$$'); EXECUTE IMMEDIATE 'CREATE TABLE tjfw_$$ AS select /*+ INDEX(a,x_attr_an) */ attribute_id  from attributes a  where attribute_name=''XMAPTO''    and tobereleased in (''Y'',''y'')  minus  (select attribute_id from  (select /*+ INDEX(a,x_attr_an) */ attribute_id   from attributes a   where attribute_name=''XMAPTO''     and tobereleased in (''Y'',''y'')     and attribute_value not like ''<>Long_Attribute<>:%''     and (a.atom_id, substr(attribute_value,1,instr(attribute_value,''~'')-1)) in    (select /*+ INDEX(a,x_attr_an) */ a.atom_id, substr(attribute_value,instr(attribute_value,''~'',1,5)+1,   	    instr(attribute_value,''~'',1,6)-instr(attribute_value,''~'',1,5)-1)     from attributes a     where attribute_name=''XMAP''       and tobereleased in (''Y'',''y'')       and attribute_value not like ''<>Long_Attribute<>:%'')   union all   select /*+ INDEX(a,x_attr_an) */ attribute_id   from attributes a, stringtab b   where attribute_name=''XMAPTO''     and tobereleased in (''Y'',''y'')     and attribute_value like ''<>Long_Attribute<>:%''     and string_id = to_number(substr(attribute_value,20))     and (a.atom_id, substr(b.text_value,1,instr(b.text_value,''~'')-1)) in        (select /*+ INDEX(a,x_attr_an) */ a.atom_id,substr(attribute_value,instr(attribute_value,''~'',1,5)+1,  	    instr(attribute_value,''~'',1,6)-instr(attribute_value,''~'',1,5)-1)         from attributes a         where attribute_name=''XMAP''           and tobereleased in (''Y'',''y'')           and attribute_value not like ''<>Long_Attribute<>:%''))   group by attribute_id)'; x:=MEME_BATCH_ACTIONS.macro_action( action=>'T', id_type=>'A', authority=>'L-JFW', table_name=>'tjfw_$$', work_id=>0, status=>'R', new_value=>'N'); MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
new src integrities|(select concept_id from classes where source='SRC' and termgroup='SRC/VAB' and tobereleased in ('N','n') and code in (select 'V-'||previous_name from source_version where current_name is not null) minus select concept_id from classes where source='SRC' and tobereleased in ('Y','y')) minus (select concept_id_1 from relationships a, classes b where relationship_name='BRT' and concept_id_2 = b.concept_id and b.source='SRC' and b.termgroup='SRC/RAB' union select concept_id_2 from relationships a, classes b where relationship_name='BRT' and concept_id_1 = b.concept_id and b.source='SRC' and b.termgroup='SRC/RAB')|Obsolete source w/o bequeathal rel to root|Y|Every obsolete versioned SRC concept is required to have a <tt>BRT</tt> bequeathal relationship to its respective root SRC concept.  This check reports concept ids violating this rule.  

To fix, use code similar to the following:<pre>
$ORACLE_HOME/bin/sqlplus $mu@$db &lt;&lt;EOF

    drop table tjfw;
    
    create table tjfw as
    select concept_id_1,concept_id_2,atom_id_1,atom_id_2,
                       relationship_name,relationship_attribute,
                       source, source_of_label,status,generated_status,
                       relationship_level,released,tobereleased,
                       relationship_id, suppressible,
                       sg_id_1, sg_type_1, sg_qualifier_1,
                       sg_id_2, sg_type_2, sg_qualifier_2,
                       source_rui, relationship_group
    from relationships where 1=0;
    
    insert into tjfw 
    select a.concept_id,b.concept_id,a.atom_id,b.atom_id,
    'BRT','','SRC','SRC','R','Y','C','N','Y',0,'N','','','','','','','',''
    from classes a, classes b, source_rank c
    where a.concept_id in 
    ((select concept_id from classes where source='SRC' and termgroup='SRC/VAB' 
    and tobereleased in ('N','n') and code in (select 'V-'||previous_name 
    from source_version where current_name is not null) minus select concept_id 
    from classes where source='SRC' and tobereleased in ('Y','y')) 
    minus 
    (select concept_id_1 from relationships a, classes b 
    where relationship_name='BRT' and concept_id_2 = b.concept_id
    and b.source='SRC' and b.termgroup='SRC/RAB' union select concept_id_2 
    from relationships a, classes b where relationship_name='BRT' 
    and concept_id_1 = b.concept_id and b.source='SRC' and b.termgroup='SRC/RAB'))
    and substr(a.code,3) = c.source
    and b.code = 'V-'||c.stripped_source
    and a.source='SRC'
    and b.source='SRC'
    and a.tty='VAB' and b.tty='RAB';

EOF

$MEME_HOME/bin/insert.pl -rels tjfw $db L-JFW</pre>
To fix the problem, insert bequeathal rels from the concepts listed to their respective root SRC concepts.

OR, if the source is no longer active, make sure <tt>source_version</tt> gets updated to reflect no current source and make all atoms in the root SRC concept unreleasable.|0|||
new src integrities|select source, 'license contact' from sims_info where  license_contact like '%'||CHR(10)||'%'  union  select source, 'license contact' from sims_info where  license_contact like '%'||CHR(13)||'%'  union  select source, 'content contact' from sims_info where  content_contact like '%'||CHR(10)||'%'  union  select source, 'content contact' from sims_info where  content_contact like '%'||CHR(13)||'%'  union  select source, 'citation' from sims_info where  citation like '%'||CHR(10)||'%'  union  select source, 'citation' from sims_info where  citation like '%'||CHR(13)||'%'|Illegal ASCII character in MRSAB data|N|Sims_info may not have new line or carriage return characters in license contact, content contact, and citation.  This can be fixed with the <a href="/webapps-meme/meme/controller?state=SourceInfoEditor">MRSAB Editor</a>.|0|||
core table semantics|select attribute_id,attribute_name from attributes where attribute_name in ('MAPFROMCOMPLEXITY','MAPFROMEXHAUSTIVE','MAPSETCOMPLEXITY','MAPTOCOMPLEXITY','MAPTOEXHAUSTIVE','UMLSMAPSETSEPARATOR') and tobereleased in ('Y','y')|Old-style map set ATN|N|There should be no releasable attributes with the following ATNs: MAPFROMCOMPLEXITY, MAPFROMEXHAUSTIVE, MAPSETCOMPLEXITY, MAPTOCOMPLEXITY, MAPTOEXHAUSTIVE, UMLSMAPSETSEPARATOR.  They should be prepended with MTH_.|0|||
new src integrities|select a.source, a.restriction_level,  c.source, c.restriction_level   from source_rank a, source_version b, source_rank c  where a.restriction_level != c.restriction_level  and a.source=current_name and c.source=previous_name|Verify restriction level did not change|N|Generally, the restriction level of a source should remain the same across source updates.  This check finds cases where this did not happen.|0|||
new src integrities|select a.source,b.source from sims_info a, sims_info b, source_rank c, source_rank d where a.source=c.source and b.source=d.source and a.source < b.source and c.stripped_source=d.stripped_source and a.insert_meta_version = b.insert_meta_version|Validate insert_meta_version|N|There should not be two versions of the same root source with the same non-null insert_meta_version value.|0|||
new src integrities|select a.source,a.remove_meta_version,b.source from sims_info a, sims_info b, source_rank c, source_rank d where a.source=c.source and b.source=d.source and a.source < b.source and c.stripped_source=d.stripped_source and nvl(a.remove_meta_version,'n') = nvl(b.remove_meta_version,'n') and a.insert_meta_version is not null and b.insert_meta_version is not null|Validate remove_meta_version|N|There should not be two versions of the same root source with the same remove_meta_version value where insert_meta_version is not null.|0|||
new src integrities|select concept_id, code from classes where source = 'SRC' and tty = 'RAB' and substr(code,3) not in (select source from source_version where current_name is not null) and tobereleased in ('Y','y')|Releasable SRC/RAB without current version|N|Every releasable root SRC concept should have a current version in source_version.|0||DECLARE    x number;  BEGIN    meme_utility.drop_it('table','tbac_$$');    execute immediate 'create table tbac_$$ as select atom_id as row_id from classes where source = ''SRC'' and concept_id in (select concept_id from classes where source = ''SRC'' and tty = ''RAB'' and substr(code,3) not in (select source from source_version where current_name is not null) and tobereleased in (''Y'',''y''))';      x:=MEME_BATCH_ACTIONS.macro_action( action=>'T', id_type=>'C', authority=>'L-BAC', table_name=>'tbac_$$', work_id=>0, status=>'R', new_value=>'N'); MEME_UTILITY.drop_it('table', 'tbac_$$');  END;|
new src integrities|select concept_id from classes a, string_ui b  where source='SRC' and tty='RAB' and string in  (select source from source_version)  and a.sui=b.sui and tobereleased not in ('Y','y')  minus  (select concept_id_1 from relationships  where relationship_name in ('BRT','BBT','BNT') and relationship_level='C'  union all  select concept_id_2 from relationships  where relationship_name in ('BRT','BBT','BNT') and relationship_level='C')|Unreleasable root SRC concept without bequeathal rel|N|Unreleasable root SRC concepts should have bequeathal relationships.|0|||
other referential integrities| 	select substr(parent_treenum,instr(parent_treenum,'.',-1)+1) from context_relationships where tobereleased in ('Y','y') and parent_treenum like '%.%' minus select aui from classes where tobereleased in ('Y','y')|CR AUI not in classes|N|AUIs in the parent treenum of releasable context rels should join to auis of releasable atoms. We presume that by just looking at the "parent aui" we can validate the entire chain of AUIs as the parent tree numbers are consistent when originally inverted and are all mapped together. If a problem is detected, it must be fixed in all places in the tree where that AUI appears, not only in the place where it is the last entry in the parent treenum.|0||DECLARE TYPE curtype is ref cursor; tmap_cur curtype; old_aui VARCHAR2(10); new_aui VARCHAR2(10); cursor cxt_cur (aui IN varchar2) IS select * from context_relationships where parent_treenum like '%'||cxt_cur.aui||'%' and relationship_name = 'PAR' and tobereleased in ('Y','y'); cxt_var cxt_cur%rowtype; ct integer := 0; BEGIN MEME_UTILITY.drop_it('table','tmap_$$'); EXECUTE IMMEDIATE 'create table tmap_$$ as  select substr(parent_treenum,instr(parent_treenum,''.'',-1)+1) as old_aui, b.aui as new_aui from context_relationships a, classes b where a.atom_id_2=b.atom_id and relationship_name=''PAR'' and a.tobereleased in (''Y'',''y'') and substr(parent_treenum,instr(parent_treenum,''.'',-1)+1) in (select substr(parent_treenum,instr(parent_treenum,''.'',-1)+1)  from context_relationships where tobereleased in (''Y'',''y'') and parent_treenum like ''%.%'' minus  select aui from classes where tobereleased in (''Y'',''y''))';  OPEN tmap_cur for 'select * from tmap_$$'; LOOP fetch tmap_cur into old_aui, new_aui; exit when tmap_cur%NOTFOUND; OPEN cxt_cur(old_aui); LOOP fetch cxt_cur into cxt_var; exit when cxt_cur%NOTFOUND; ct := ct + 1; update context_relationships set parent_treenum = substr(parent_treenum,1,instr(parent_treenum,old_aui)-1) || new_aui || substr(parent_treenum,instr(parent_treenum,old_aui)+length(old_aui)) where relationship_id = cxt_var.relationship_id; END LOOP; CLOSE cxt_cur; COMMIT; END LOOP; MEME_UTILITY.put_message('ct == ' || ct);  MEME_UTILITY.drop_it('table','tmap_$$'); END;|
core table semantics|select a.relationship_id relationship_id, c.relationship_id as inverse_relationship_id, a.source from relationships a, inverse_relationships_ui b, relationships c where a.rui = b.rui and b.inverse_rui=c.rui  and a.tobereleased in ('Y','y') and c.tobereleased in ('Y','y')  and a.relationship_id < c.relationship_id|Rels represented in both directions|N|Find cases of relationships represented in both directions.  In the MID, rels should be represented in only one direction.  Violations should be reviewed, corrected as needed and the inverters producing the original data should be informed so that they can clean up the inversion.|1430|MSHFX and MSHFC rels which should be cleaned up at the next MSH update.|DECLARE x number; BEGIN MEME_UTILITY.drop_it('table', 'tjfw_$$'); EXECUTE IMMEDIATE 'create table tjfw_$$ as select a.relationship_id relationship_id, c.relationship_id as row_id from relationships a, inverse_relationships_ui b, relationships c where a.rui = b.rui and b.inverse_rui=c.rui and a.tobereleased in (''Y'',''y'') and c.tobereleased in (''Y'',''y'') and a.relationship_id < c.relationship_id'; x:=MEME_BATCH_ACTIONS.macro_action(action=>'T', id_type=>'R', authority=> 'L-JFW', table_name=>'tjfw_$$', work_id=>0, status=>'R', new_value=>'n'); MEME_UTILITY.drop_it('table', 'tjfw_$$'); END;|
core table semantics|select concept_id, attribute_name from attributes   where concept_id in (select concept_id from classes where tty='XM' and tobereleased in ('Y','y'))  and attribute_name not like '%XMAP%' and tobereleased in ('Y','y') and source = 'MTH'  group by concept_id, attribute_name having count(distinct atui)>1|Duplicate MTH Map Set Attributes|N|Map set concept attributes of the same name should not have different ATUIs.  Because certain mapset attributes are owned by MTH, source updates will cause duplicate ATNs with different ATVs in mapset concepts.  Use the following query to figure out which ones are correct:<br><pre>select distinct concept_id,attribute_id,tobereleased,attribute_name,attribute_value 
from attributes 
where source='MTH' 
and attribute_name in ('FROMVSAB','TOVSAB','MAPSETVSAB');</pre>|0|||
new src integrities|select c.concept_id,c.atom_id,c.code,s.string from classes c, string_ui s  where source='SRC' and tty='SSN'   and tobereleased in ('Y','y')  and c.isui=s.isui  and c.isui in  (select isui from classes  where source='SRC' and tty='SSN'  and tobereleased in ('Y','y')  group by isui having count(concept_id)>1)|Non-unique SRC/SSN string|N|SRC/SSN strings should be unique.|0|||
source specific integrities|select count(*) ct, attribute_name,a.source from attributes a, classes b  where a.atom_id = b.atom_id  and b.source = (select current_name from source_version where source='MSH')  and b.tty != 'MH'  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and a.sg_type like '%SOURCE_DUI'  and b.code like 'D%'  GROUP BY attribute_name,a.source|D MSH attributes incorrectly mapped|N|D MSH attributes mapped by %SOURCE_DUI should be connected to atoms of term type MH.|0|||
core table semantics|select normalized_source, source from source_rank  where source in    (select source from classes where tobereleased in ('Y','y')    union select source from foreign_classes where tobereleased in ('Y','y'))      and normalized_source not in     (select current_name from source_version where current_name is not null)|Non-current normalized source|N|Normalized_source values are the SAB values used in the release and for all releasable sources should be set to current SAB names.  This query identifies cases where normalized source was probably incorrectly not updated and left set to some previous version source.|0|||
core table semantics|select attribute_id, concept_id, attribute_name, attribute_Value from attributes where attribute_level = 'C' and attribute_name!='SEMANTIC_TYPE' and concept_id in  (SELECT concept_id FROM attributes WHERE concept_id IN (SELECT concept_id FROM classes WHERE tty='XM' AND tobereleased in ('Y','y'))  AND tobereleased in ('Y','y')  AND  attribute_name != 'SEMANTIC_TYPE'  AND attribute_level = 'C')|Non-S-level attributes connected to XMAP concepts|N|Attributes connected to XM concepts should be S level (except for SEMANTIC_TYPE).|0|||
new src integrities|select /*+PARALLEL(a)*/ count(*),source from attributes a where source_atui is not null group by source|Attributes with non-null source_atui|N|Attributes should have null source_atuis.  Currently, there are no sources with non-null source_atuis, but this may change in the future.|0|||
other referential integrities|select /*+PARALLEL(a)*/ a.atom_id, a.suppressible from classes a, termgroup_rank b where tobereleased in ('Y','y')  and a.suppressible in ('E','N') and a.termgroup=b.termgroup and b.suppressible='Y'  union select /*+PARALLEL(a)*/ a.atom_id, a.suppressible from classes a, termgroup_rank b where tobereleased in ('Y','y') and a.suppressible ='Y' and a.termgroup=b.termgroup and b.suppressible='N'|Conflicting suppressibility|N|Any atom whose termgroup is suppressible (suppressible=Y in termgroup_rank) should not have a suppressibility value of E or N.  Any atom whose termgroup is NOT suppressible should NOT have a suppressibility value of Y.|0|||
source specific integrities|select count(*) ct, relationship_name, relationship_attribute, a.source  from relationships a, classes b  where a.atom_id_1 = b.atom_id  and b.source = (select current_name from source_version where source='MSH')  and b.tty != 'MH'  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and a.sg_type_1 like '%SOURCE_DUI'  and b.code like 'D%'  GROUP BY relationship_name, relationship_attribute, a.source  UNION  select count(*) ct, relationship_name, relationship_attribute, a.source  from relationships a, classes b  where a.atom_id_2 = b.atom_id  and b.source = (select current_name from source_version where source='MSH')  and b.tty != 'MH'  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and a.sg_type_2 like '%SOURCE_DUI'  and b.code like 'D%'  GROUP BY relationship_name, relationship_attribute, a.source|D MSH relationships incorrectly mapped|N|D MSH relationships mapped by %SOURCE_DUI should be connected to atoms of term type MH.|0|||
source specific integrities|select /*+PARALLEL(a)*/ count(*) ct, attribute_name,a.source from attributes a, classes b  where a.atom_id = b.atom_id  and b.source = (select current_name from source_version where source='SNOMEDCT')  and b.tty not in ('PT','OP')  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and a.sg_type like '%SOURCE_CUI' and source_cui !='325973005' GROUP BY attribute_name,a.source|SNOMEDCT attributes incorrectly mapped|N|SNOMEDCT attributes mapped by %SOURCE_CUI should be connected to atoms of term type PT,OP.  If there is no PT or OP in the concept, an OF may be used instead.  One example of this is SNOMEDCT scui 325973005.  This scui is specifically excluded in the query (may need to be changed in the future).|0|||
source specific integrities|select count(*) ct,relationship_name, relationship_attribute, a.source from relationships a, classes b  where a.atom_id_1 = b.atom_id  and b.source = (select current_name from source_version where source='SNOMEDCT')  and b.tty not in ('PT','OP')  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and a.sg_type_1 like '%SOURCE_CUI'  GROUP BY relationship_name, relationship_attribute, a.source  UNION  select count(*) ct, relationship_name, relationship_attribute, a.source from relationships a, classes b  where a.atom_id_2 = b.atom_id and b.source_cui != '325973005' and b.source = (select current_name from source_version where source='SNOMEDCT')  and b.tty not in ('PT','OP')  and a.tobereleased in ('Y','y') and b.tobereleased in ('Y','y')  and a.sg_type_2 like '%SOURCE_CUI'  GROUP BY relationship_name, relationship_attribute, a.source|SNOMEDCT relationships incorrectly mapped|N|SNOMEDCT relationships mapped by %SOURCE_CUI should be connected to atoms of term type PT,OP.  If there is no PT or OP in the concept, an OF may be used instead. One example of this is SNOMEDCT scui 325973005. This scui is specifically excluded in the query (may need to be changed in the future).|0|||
new src integrities|select a.source, real_insertion_start, insertion_date from sims_info a, classes b where b.code = 'V-' || a.source and tobereleased in ('Y', 'y') and to_date(to_char(real_insertion_start, 'DD-Mon-YYYY')) > to_date(to_char(insertion_date, 'DD-Mon-YYYY')) and insertion_date > '31-dec-2002' and tty='VAB'|Validate real_insertion_start against SRC/VAB|N|The sims_info.real_insertion_start should generally be the same day as the insertion date of the SRC/VAB corresponding to the source.  This check finds cases where this is not so.  For large sources, it may not match if the SRC concepts are not inserted until the next day, or so.  To fix, either create an adjustment OR set the SRC/VAB insertion date to match the correct real_insertion_start.|0|||
string unique identifier integrity|select isui,lui,string from string_ui  where isui in (select isui from string_ui where language='ENG' group by isui having count(distinct lui)>1)  |ISUI not contained in LUI|N|Each ISUI (case-insensitive string) must have exactly one LUI (normalized string) associated with it.  Violations of this may indicate a bug in LVG luiNorm program.|0|||
core table semantics|select atom_id,concept_id, source from classes where last_release_rank >4|Find out of range last_release_rank|N|A recent change allows lrr values to be 5 for the duration of a test insertion.  For a transition period, they may be be correctly set back to 0 at the end of the insertion.  This finds such cases.|0||update classes set last_release_rank=0 where last_release_Rank=5|
core table semantics|Select concept_id from classes where last_release_cui is null and tobereleased in ('Y','y') and insertion_date < (select min(timestamp) from molecular_Actions) and tty not in ('MM','TM')  |Confirm last_release_cui set from previous release|N|Atoms that are releasable and inserted before the current editing cycle should have non-null last_release_cui values.  If not, it likely  means the "Set Release CUIs" post-copyout step was not run properly.|0|||
new src integrities|SELECT b.concept_id, b.atom_id, string FROM string_ui a, classes b  WHERE a.sui=b.sui AND b.source='SRC'  AND b.tty='VAB' AND b.tobereleased in ('N','n')  AND string in (SELECT current_name FROM source_version)|Unreleasable SRC concept for current version|N|Current version VSABs should not have unreleasable SRC concepts.  This causes the RMETA to become erroneously set during pre-production.  In addition to making atoms of this concept unreleasable, the VSAB atom should be deleted.|0|||
source specific integrities|WITH a AS (SELECT substr(attribute_value,instr(attribute_value,'<',1,b.row_num)+1,       instr(attribute_value,'>',1,b.row_num)-instr(attribute_value,'<',1,b.row_num)-1) str  FROM attributes, (select rownum row_num from max_tab where rownum<6) b  WHERE attribute_name='XMAPTO'        AND tobereleased in ('Y','y')  AND attribute_value not like '<>Long%'        AND concept_id IN            (SELECT concept_id FROM attributes a, source_version b             WHERE attribute_name='TOVSAB'               AND attribute_value = b.previous_name               AND b.source = 'MSH') ),    b AS (SELECT substr(text_value,instr(text_value,'<',1,c.row_num)+1,       instr(text_value,'>',1,c.row_num)-instr(text_value,'<',1,c.row_num)-1) str  FROM attributes a, stringtab b, (select rownum row_num from max_tab where rownum<6) c  WHERE attribute_name='XMAPTO'        AND tobereleased in ('Y','y')  and to_number(substr(a.attribute_value,20)) = b.string_id  AND attribute_value like '<>Long%'        AND concept_id IN            (SELECT concept_id FROM attributes a, source_version b             WHERE attribute_name='TOVSAB'               AND attribute_value = b.previous_name               AND b.source = 'MSH'))  (SELECT * FROM a WHERE str is not null   UNION ALL SELECT * FROM b WHERE str is not null)  minus select string from string_ui a, classes b  where a.sui = b.sui and b.source in    (select current_name from source_version where source='MSH')|Bad MSH ATX strings|N|In the MSH ATX map set concept (C1306694), there are some XMAPTO attributes whose values contain strings that do not correspond to current-version MSH strings.  This should not be allowed, after the msh_atx.csh script runs during the MSH insertion.

This check finds strings referred to in the micro-syntax of the XMAPTO values that do not correspond to any MSH atoms.

For violations of this check, double-check why the msh_atx.csh script did not either modify these entries to current MSH strings or make them inactive.

To fix, either map these values to current MSH strings or mark them (and corresponding XMAP and XMAPFROM attributes) as unreleasable.|0|||
new src integrities|select atom_id from classes where source = 'SRC' AND tty != 'RHT' AND atom_id IN (SELECT atom_id_2 FROM context_relationships WHERE relationship_name='PAR')|Illegal Context Tree-top|N|Hierarchy tree-top atoms should either be source atoms or SRC owned atoms whose TTY is RHT.  This check finds violations of that rule.|0|||
core table semantics|select distinct b.source, a.tty from termgroup_rank a, source_version b   where suppressible='N' and tty in  (select value from meme_properties where key='tty_class' and description='obsolete')  and substr(termgroup,1,instr(termgroup, '/')-1) = current_name|Non-suppressible Term Type with Obsolete Class|N|A termgroup with an obsolete tty_class should have suppressibility=N.|0|||
unique identifier (ui) integrity|select rui from inverse_relationships_ui minus select rui from relationships_ui|Illegal inverse rui entry|N|There should be no "inverse" records for nonexistent RUIs.  The cleanup operations should handle this properly.|0|||
