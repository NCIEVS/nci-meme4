<html>
<head>
            
  <meta http-equiv="Content-Type"
 content="text/html; charset=utf8">
            
  <meta name="Author" content="Brian Carlsen">
            
  <meta name="Description"
 content="This document describes the MEME_INTEGRITY_PROC API.">
  <title>MEME - Developer Guides - PL/SQL Documentation - MEME_INTEGRITY_PROC</title>
</head>
  <body text="#000000" bgcolor="#ffffff" link="#3333ff" vlink="#999999"
 alink="#ff0000">
  s    
<center>   
<h2> MEME_INTEGRITY_PROC   
<hr></h2>
  </center>
   <i>Key</i>   
<blockquote>&nbsp;       
  <table width="70%" nosave="">
   <tbody>
        <tr nosave="">
   <td nosave=""><sup><font color="#3366ff"><font size="-2">(r)</font></font></sup></td>
    <td><b><font size="-1">Required</font></b></td>
    <td><font size="-1">QA bins produced from this function must be completely 
 edited.</font></td>
   </tr>
    <tr>
   <td><sup><font color="#3366ff"><font size="-2">(i)</font></font></sup></td>
    <td><b><font size="-1">IC Check</font></b></td>
    <td><font size="-1">This function implements an integrity check</font></td>
   </tr>
    <tr nosave="">
   <td nosave=""><sup><font color="#3366ff"><font size="-2">(u)</font></font></sup></td>
    <td><b><font size="-1">Untested</font></b></td>
    <td><font size="-1">This function is either unimplemented or untested</font></td>
   </tr>
             
    </tbody>      
  </table>
   </blockquote>
   <i>Package Description &amp; General Methods.</i> <br>
  &nbsp;   
<center>  
<table border="1" cellpadding="2" width="90%" nosave="">
   <tbody>
      <tr nosave="">
   <td nosave="">This package contains functions which compute various integrity 
 conditions for concepts in the database.&nbsp; Many of the functions are 
used by the matrix initializer to determine the integrity status of concepts 
for the purposes of editing management.&nbsp; Most of the functions in this 
package can be used by the EMS to generate QA checklists that are reviewed 
by editors.&nbsp;               
      <p>The methods in this package have some standard parameters.&nbsp;
 The presence of a cluster_flag parameter indicates that the function can
return a table in either raw form (<tt>CLUSTER_NO</tt>) or clustered form
(<tt>CLUSTER_YES</tt>).&nbsp; The presence of a table_name parameter indicates
that the function can operate on a subset of the database or on the whole
database (<tt>EMPTY_TABLE</tt>).&nbsp; Every function takes a work_id that
can be used to track any errors produced by the procedures in the <tt><a
 href="/MEME/Data/tables.sql">meme_errors</a></tt>  table. <br>
  &nbsp; </p>
               
      <p><a name="recompute_cluster_history"></a><img
 src="/images/green-ball.gif" height="12" width="12">
        <b>recompute_cluster_history</b> </p>
               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION recompute_cluster_history (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN VARCHAR2,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to_delete IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to_insert IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE );</pre>
                  
      <dl>
        <dd> To enable the <a
 href="/MEME/Documentation/plsql_mi.html#matrix_updater">matrix  updater</a>,
a history of concepts clustered by integrity checks has to be maintained.&nbsp;
This procedure takes a name to represent what is being clustered, a table
name of concepts to remove from the stored clusters (to_delete) and a table
name of new values (to_insert).</dd>
      </dl>
   </td>
   </tr>
         
  </tbody>  
</table>
  </center>
      
<p><i>Integrity Functions</i> <br>
  &nbsp; </p>
   
<center>  
<table border="1" cellpadding="2" width="90%" nosave="">
   <tbody>
      <tr>
   <td>The procedures in this section correspond to integrity checks that 
are part of the MEME <a
 href="/MEME/Documentation/integrity_system.html">integrity  system</a>.&nbsp;
A mapping of integrity check names (<tt><a href="/MEME/Data/tables.sql">integrity_constraints.ic_name</a></tt>) 
 to functions in this package can be found by <tt>SELECT * FROM code_map WHERE
type = 'integrity_check'</tt>.&nbsp; The matrix initializer (<a
 href="/MEME/Documentation/plsql_mi.html">MEME_INTEGRITY</a>)  makes use
of this mapping to convert an integrity vector from the <tt><a
 href="/MEME/Data/tables.sql">ic_applications</a></tt>  table into calls
to these functions.               
      <p><sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="missing_sty"></a></font></font></sup><b>missing_sty</b>
      </p>
               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION missing_sty (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of unapproved concepts lacking a releasable semantic type.&nbsp; Clusters
 are single concepts. This corresponds with integrity check MGV_M1.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="missing_sty_matrixinit"></a><b>missing_sty_matrixinit</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION missing_sty_matrixinit (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This is a version of the <a href="#missing_sty">missing_sty</a>
 check designed to work with the matrix initializer.&nbsp; Where <a
 href="#missing_sty">missing_sty</a> returns only status N concepts, this
 returns <i>all</i> concepts lacking a releasable semantic type.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="empty_concepts"></a></font></font></sup><b>empty_concepts</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION empty_concepts(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts lacking any releasable atoms.&nbsp; Clusters are single concepts.
 This corresponds with integrity check <tt>MGV_M3</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="auto_merged"></a></font></font></sup><b>auto_merged</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION auto_merged(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts which have atoms that were touched by the merge engine. Clusters
 are single concepts. This corresponds with integrity check <tt>MGV_I2</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="demotions"></a></font></font></sup><b>demotions</b>    
          
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION demotions(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have demotions between them. Clusters are pairs of concepts.
 This corresponds with integrity check <tt>MGV_I3</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="pir"></a></font></font></sup><b>pir</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION pir(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have PIR relationships between them. Clusters are pairs
of concepts.This corresponds with integrity check <tt>MGV_I4</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="non_human"></a></font></font></sup><b>non_human</b>    
          
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION non_human(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts which contain a <tt>NON_HUMAN</tt> attribute flag. Clusters
are  single concepts. This corresponds with integrity check <tt>MGV_I5</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="true_orphan"></a></font></font></sup><b>true_orphan</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION true_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have no releasable relationships (including context relationships) 
 to other concepts in the MID. Clusters are single concepts. This corresponds 
 with integrity check <tt>DT_M2</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="msh_d_orphan"></a><a name="msh_q_orphan"></a><a
 name="msh_c_orphan"></a></font></font></sup><b>msh_d_orphan, msh_q_orphan,
 msh_c_orphan</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_d_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION msh_q_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION msh_c_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> These functions return a table name containing a (potentially
 clustered) set of concepts that contain entry terms which are orphans with
 respect to their main headings.&nbsp; In other words, the entry terms are
 in separate concepts from their main headings and there are no approved/releasable 
 relationships to those main heading concepts.&nbsp; These three functions 
 compute this predicate for current MeSH D, Q, and C codes, respectively. 
Clusters are pairs: the orphan concept and the main heading concept. These 
functions correspond with integrity checks <tt>DT_I8A</tt>, <tt>DT_I8B</tt>,&nbsp; 
and           <tt>DT_I8C</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="xr_msh_d_orphan"></a><a name="xr_msh_q_orphan"></a><a
 name="xr_msh_c_orphan"></a></font></font></sup><b>xr_msh_d_orphan, xr_msh_q_orphan,
 xr_msh_c_orphan</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION xr_msh_d_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION xr_msh_q_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION xr_msh_c_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> These functions return a table name containing a (potentially
 clustered) set of concepts that contain entry terms which are orphanned
from  their main headings by the presence of a concept level XR relationship.&nbsp; 
 In other words, there is a concept level XR relationship between a concept 
 containing current MSH entry terms and the concept containing the respective 
 main headings.&nbsp; These three functions compute this predicate for current 
 MeSH D, Q, and C codes, respectively. Clusters are pairs: the orphan concept 
 and the main heading concept. These functions correspond with integrity checks
          <tt>DT_I8AXR</tt>, <tt>DT_I8BXR</tt>, and <tt>DT_I8CXR</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="msh_et_synonym"></a></font></font></sup><b>msh_et_synonym</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_et_synonym(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a clustered set of concepts
that are potential current MeSH entry term synonyms.&nbsp; These are cases
where concepts containing current MeSH entry terms have the same relationship
to the same MeSH main heading concept. The clusters contain all concept of
the potential synonym concepts <i>and</i> the main heading concept that brings
 them together. This corresponds with integrity check <tt>DT_I9</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="msh_mh_diff"></a></font></font></sup><b>msh_mh_diff</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_mh_diff(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a clustered set of concepts
pairs where cross-year MeSH main headings with the same code are in different
concepts.&nbsp; A clusters consists of a concept containing a previous year
MeSH main heading and a concept containing the current year MeSH main heading
with the same code if the two are in different concepts.&nbsp; This corresponds
to integrity check <tt>DT_I10</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="sfo_lfo"></a></font></font></sup><b>sfo_lfo</b>         
     
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION sfo_lfo(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concept pairs across which <tt>SFO/LFO</tt> relationships span. Clusters
 are pairs of concepts. This corresponds with integrity check <tt>DT_I11</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="ny_sty"></a></font></font></sup><b>nh_sty</b>          
    
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION nh_sty(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have <tt>NON_HUMAN</tt> attribute flags and are lacking
one of a particular set of semantic types that go with <tt>NON_HUMAN</tt>
flags. Clusters are single concepts. This data driven check uses the <tt><a
 href="/MEME/Data/tables.sql">nhsty</a></tt> table..&nbsp;  This corresponds
with integrity check <tt>DT_I12</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="separated_pm"></a></font></font></sup><b>separated_pm</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION separated_pm(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts where a current year MeSH <tt>PM</tt> is separated from a current
 year MeSH main heading or entry term with the same code. Clusters contain
 the <tt>MSH/PM</tt> atom and all of the main heading/entry term concepts
that match it on code. This corresponds to integrity check <tt>DT_I13</tt>.</dd>
      </dl>
   </td>
   </tr>
         
  </tbody>  
</table>
  </center>
      
<p><i>Multiple Meaning Functions</i> <br>
  &nbsp; </p>
   
<center>  
<table border="1" cellpadding="2" width="90%" nosave="">
   <tbody>
      <tr>
   <td>Many of the functions in this section are also implementations of
integrity  checks.&nbsp; However, what is important here is that each function
deals  with some part of the complexity that arises from multiple meanings.
              
      <p><sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="ambig_no_pn"></a></font></font></sup><b>ambig_no_pn</b>
      </p>
               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION ambig_no_pn(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that contain ambiguous strings and lack <tt>MTH/PN</tt> atoms
 to disambiguate them.&nbsp; Clusters include the concept lacking the <tt>PN</tt>
 and all other concepts containing that ambiguous string. This corresponds
 with integrity check <tt>DT_PN1</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="multiple_pn"></a></font></font></sup><b>multiple_pn</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION multiple_pn(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have multiple releasable <tt>MTH/PN</tt> atoms in the same
 concept.&nbsp; Clusters are single concepts.&nbsp; This corresponds with
integrity check <tt>DT_PN2</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="pn_no_ambig"></a></font></font></sup><b>pn_no_ambig</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION pn_no_ambig(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that contain releasable <tt>MTH/PN</tt> atoms but do not contain
 ambiguous strings.&nbsp; Clusters are single concepts.&nbsp; This corresponds
 with integrity check <tt>DT_PN3</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="pn_pn_ambig"></a></font></font></sup><b>pn_pn_ambig</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION pn_pn_ambig(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts containing identical releasable <tt>MTH/PN</tt> atoms.&nbsp;&nbsp;
 Clustering is done by the <tt>MTH/PN</tt> string.&nbsp; This corresponds
with integrity check <tt>DT_PN4</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="ambig_no_rel"></a></font></font></sup><b>ambig_no_rel</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION ambig_no_rel(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have an ambiguous string and lack relationships to all
other  concepts sharing that ambiguous string.&nbsp;&nbsp;&nbsp; Clusters
include  all concepts containing the ambiguous string, not just those lacking
the relationships. This corresponds with integrity check <tt>DT_MM1</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="multiple_mm"></a></font></font></sup><b>multiple_mm</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION multiple_mm(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have multiple relasable <tt>MTH/MM</tt> atoms with the
same  base string.&nbsp; Clusters are single concepts. This corresponds with
integrity  check <tt>DT_MM2</tt>.&nbsp; This function must be run on the
whole database  and not a subset.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="mm_no_ambig"></a></font></font></sup><b>mm_no_ambig</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION mm_no_ambig(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that contain <tt>MTH/MM</tt> atoms but do not contain any ambiguous
 strings matching the <tt>MTH/MM</tt>'s base string.&nbsp; Clusters are single
 concepts. This corresponds with integrity check <tt>DT_MM3</tt>.</dd>
      </dl>
   <sup><font color="#3366ff"><font size="-2">(i)(r)<img
 src="/images/green-ball.gif" height="12" width="12">
        <a name="mm_misalign"></a></font></font></sup><b>mm_misalign</b>
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION mm_misalign(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts involving cases where one concept contains multiple <tt>MTH/MM</tt>
 atoms with the same string, but not a matching ambiguous string, and another 
 concept contains that ambiguous string but no <tt>MTH/MM</tt> atoms.&nbsp; 
 This can result from editors splitting ambiguous strings out of concepts 
but not bringing the <tt>MTH/MM</tt> matching it in the split. Clusters are 
all concepts involving that ambiguous string.&nbsp; This corresponds with 
integrity check <tt>DT_MM4</tt>. This function must run on the whole database 
and not a subset.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="separated_strings"></a><b>separated_strings</b>         
     
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION separated_strings(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; table_name IN VARCHAR2 := MEME_CONSTANTS.EMPTY_TABLE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts contain ambiguous strings.&nbsp; Clusters include concepts sharing
 the same ambiguous string. Many of the multiple meaning checks make use
of  this procedure internally.&nbsp; For a simple listing of ambiguous strings 
 (with the ambiguous isui), take a look at the <tt><a
 href="/MEME/Data/views.sql">separated_strings</a></tt>  view.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <sup><font color="#3366ff"><font size="-2">(r)<a name="ambig_pn"></a></font></font></sup><b>ambig_pn</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION ambig_pn(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts involving cases where an <tt>MTH/PN</tt> atom is itself ambiguous
 but its concept does not contain a matching ambiguous non <tt>MTH/PN</tt>
 atom.  <tt>MTH/PN</tt> atoms may be ambiguous, but generally this is only
 correct if the concept containing an ambiguous <tt>MTH/PN</tt> atom <i>also</i> 
 contains a non-<tt>MTH/PN</tt> atom with the same string.&nbsp; Clusters 
contain the <tt>MTH/PN</tt> concept and all other concepts containing the 
ambiguous string.&nbsp; This does not correspond to an integrity check.&nbsp; 
This function must run on the whole database and not a subset.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="pure_u_ambig_no_pn"></a><b>pure_u_ambig_no_pn</b>      
       
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION pure_u_ambig_no_pn(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This is the same predicate as the <tt><a
 href="#ambig_no_pn">ambig_no_pn</a></tt> function from above but applied
 to concepts whose only releasable atoms are status <tt>U</tt>.&nbsp; The
purpose of this check is to resolve ambiguities among the supplementary concepts
which may be more difficult than among regular concepts.&nbsp; This does
not correspond to an integrity check.&nbsp; This function must run on the
whole database and not a subset.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="approved_tm"></a><b>approved_tm</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION approved_tm(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that are approved and contain <tt>MTH/TM</tt> atoms.&nbsp; This
 query is used to review the <tt>MTH/TM</tt> atoms which are temporary <tt>MTH/MM</tt> 
 atoms before they are converted into <tt>MTH/MM</tt> atoms.&nbsp; This does
 not correspond to an integrity check.&nbsp; This function must run on the
 whole database and not a subset.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <sup><font color="#3366ff"><font size="-2">(r)<a
 name="merged_tm"></a></font></font></sup><b>merged_tm</b>              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION merged_tm(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that contain <tt>MTH/TM</tt> atoms whose base string matches
other           <tt>MTH/TM</tt> or <tt>MTH/MM</tt> atoms in the same concept.&nbsp;
 This function is used to find cases of <tt>MTH/TM</tt> atoms that are going
 to go away to validate that the merges which brought them with the other
          <tt>TM</tt> or <tt>MM</tt> atoms are valid.&nbsp; This does not
correspond to an integrity check.&nbsp; This function must run on the whole
database and not a subset.</dd>
      </dl>
   </td>
   </tr>
         
  </tbody>  
</table>
  </center>
      
<p><i>QA Bin Functions.</i> <br>
  &nbsp; </p>
   
<center>  
<table border="1" cellpadding="2" width="90%" nosave="">
   <tbody>
      <tr nosave="">
   <td nosave="">The following functions are used by the EMS to generate
QA  bins.&nbsp; These checks do <i>not</i> correspond with integrity system
checks  unless otherwise indicated. Additionally, all of these functions
are run database-wide and not on subsets of concepts.               
      <p><img src="/images/green-ball.gif" height="12" width="12">
        <a name="mxsuppr"></a><b>mxsuppr</b> </p>
               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION mxsuppr(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts containing releasable atoms of mixed suppressibility. Clusters
 are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <b><a name="checksrc"></a>checksrc</b><b></b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION checksrc(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of status 'N' concepts containing SRC atoms.&nbsp; This query is used to
review SRC concepts that likely need updating. Clusters are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="mthu"></a><b>mthu</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION mthu(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_YES,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts containing status <tt>U</tt>, <tt>source=MTH</tt> atoms.&nbsp;
 Clusters are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <sup><font color="#3366ff"><font size="-2">(r)<a name="msh_mrg"></a></font></font></sup><b>msh_mrg</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_mrg(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts containing current version MeSH atoms with different codes.
There  are a few exceptions: (a) concepts containing publication type/descriptor
 merges, (b) MeSH D number atoms merged with MeSH <tt>GQ</tt> and <tt>XQ</tt>
 atoms.&nbsp; Clusters are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <sup><font color="#3366ff"><font size="-2">(r)<a name="msh_sep"></a></font></font></sup><b>msh_sep</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_sep(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts involving current year MeSH main heading code splits.&nbsp;
A  cluster consists of a pair of concepts containing a current year MeSH
main  heading atom with the same code.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <sup><font color="#3366ff"><font size="-2">(r)<a name="msh_n1"></a></font></font></sup><b>msh_n1</b> 
              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_n1(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts involving current year MeSH <tt>N1</tt> atoms split from their
 main headings (<tt>MH</tt> or <tt>NM</tt>).&nbsp; A cluster consists of
the  concept containing the <tt>MSH/N1</tt> atom and the concept containing
the  main heading with the same code.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="rcd_mrg"></a><a name="snm_mrg"></a><a name="umd_mrg"></a><a
 name="hcpcs_mrg"></a><b>rcd_mrg, snm_mrg, umd_mrg, hcpcs_mrg</b>        
     
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION rcd_mrg(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION snm_mrg(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION umd_mrg(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION hcpcs_mrg(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts involving code merges in the current version of <tt>RCD</tt>,
           <tt>SNM</tt>, <tt>UMD</tt>, or <tt>HCPCS</tt>.&nbsp; Clusters
are  single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="rcd_sep"></a><a name="lnc_sep"></a><a name="cpt_split"></a><b>rcd_sep, 
 lnc_sep, cpt_split</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION rcd_sep(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION lnc_sep(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION cpt_split(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts involving code splits in the current versions of <tt>RCD</tt>
 or <tt>LNC</tt>. In the case of <tt>CPT</tt> it is same code <tt>CPT</tt>
 and <tt>HCPCS</tt> atoms that are split across concepts.&nbsp; Clusters
are  pairs of concepts containing atoms within the source having the same
code.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="pdq_orph"></a><a name="umd_oprh"></a><a name="cpt_orph"></a><b>pdq_orph, 
 umd_orph, cpt_orph</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION pdq_orph(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION umd_orph(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);<br><br>&nbsp;&nbsp;&nbsp; FUNCTION cpt_orph(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts involving "entry terms" in <tt>PDQ</tt>, <tt>UMD</tt>, or <tt>CPT</tt> 
 which are separated from their "main headings" and the two concepts are not
connected by a relationship from that source.&nbsp; A cluster is a pair of
concepts where one contains the "entry term" and the other contains the "main
heading".</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="styisa"></a><b>styisa</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION styisa(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts with ancestor-decendent STY relationships.&nbsp; The STY relationships 
 are from <tt>srstre2</tt>.&nbsp; A cluster involves a concept with an ancestory 
 STY and a concept with a decendent STY.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="icdproc"></a><b>icdproc</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION icdproc(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts containing <tt>ICD</tt> atoms with 2 digit codes that do not
have procedure STYs.&nbsp; Clusters are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="stydrug"></a><b>stydrug</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION stydrug(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts with STYs other than 'Medical Device' co-ocurring with 'Clinical&nbsp; 
 Drug'. Clusters are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="mthdt_nomm"></a><b>mthdt_nomm</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION mthdt_nomm(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts which contain <tt>MTH/DT</tt> atoms but not <tt>MTH/MM</tt>
atoms.&nbsp;  Clusters are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="cui_splits"></a><b>cui_splits</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION cui_splits(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts that have been split with respect to <tt>last_release_cui</tt>.&nbsp;
 Clusters contain all concepts that share atoms with a particular <tt>last_release_cui</tt> 
 value.&nbsp;</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="merged_cui"></a><b>merged_cui</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION merged_cui(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This functions produces a list of concept ids which contain
CUIs that will appear in the next <tt>MERGED.CUI</tt> file.&nbsp;</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="msh_mui_merge"></a><b>msh_mui_merge</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_mui_merge(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This functions produces a list of concepts containing atoms
with different MSH <tt>MUI</tt> values.&nbsp;</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="msh_mui_split"></a><b>msh_mui_split</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION msh_mui_split(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This functions produces a list of concepts across which a MSH
           <tt>MUI</tt> is split. The results are clustered by <tt>MUI</tt>
 values.&nbsp;</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="suspect_cui"></a><b>suspect_cui</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION suspect_cui(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This functions produces a list of concepts whose CUI assignments
 are suspect, due to splits and merges.&nbsp; Assignment of CUIs should always
 invovle this set..&nbsp;</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="deleted_cui"></a><b>deleted_cui</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION deleted_cui(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This functions produces a list of concept ids which contain
CUIs that are associated with only unreleasable atoms.&nbsp; Such concepts
that have been bequeathed will <i>not </i>appear on the list..</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="deleted_cui_uwda"></a><b>deleted_cui_uwda</b>          
    
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION deleted_cui_uwda(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This functions calls <tt><a href="#deleted_cui">deleted_cui</a>
           </tt>and then restricts itself to UWDA-only cases..</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="deleted_cui_split"></a><b>deleted_cui_split</b>         
     
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION deleted_cui_split(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> This function produces a list of concept ids which contain CUIs
 that will appear in the next <tt>DELETED.CUI</tt> file. These CUIs are considered 
 deleted because all atoms assigned these CUI in the previous release have 
 been split out of the original concept and merged into concepts containing 
 higher ranking atoms. The results are clustered by CUI.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="mth_only"></a><b>mth_only</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION mth_only(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts whose only releasable atoms are <tt>source=MTH</tt>. Clusters
 are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="mth_clone_rels"></a><b>mth_clone_rels</b>              
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION mth_clone_rels(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts between which there are multiple identical relationships (rel,
 rela, level) from different sources.&nbsp; Clusters are pairs of concepts
 connected in this way.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="rescue_lt"></a><b>rescue_lt</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION rescue_lt(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts containing lexical tags that are candidates for rescue.&nbsp;
 These are tags that will disappear if not saved because they are attached
 to atoms which have been made obsolete.&nbsp; Clusters are single concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="rescue_orphan"></a><b>rescue_orphan</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION rescue_orphan(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts which are on the verge of being orphans because their only relationships 
 are connected to unreleasable atoms. Clusters are single concepts.&nbsp; 
Editors reviewing these cases should attempt to replace the soon to be gone 
relationships with concept level ones.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="rescue_pair"></a><b>rescue_pair</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION rescue_pair(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts from relationships to rescue.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="sr_split"></a><b>sr_split</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION sr_split(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a (potentially clustered) set
 of concepts in which one concept contains an atom from an old version of
a source and a second concept contains the replacement atom from the new
version of the source.&nbsp; This check looks for safe-replacement splits.&nbsp;
Clusters are a pair of concepts.</dd>
      </dl>
   <img src="/images/green-ball.gif" height="12" width="12">
        <a name="scd_difflui"></a><b>scd_difflui</b>               
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION scd_difflui (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns concepts with multiple normal forms having different
 LUIs. &nbsp;Most likely one of the normal forms is wrong, or the concept
should be split apart.</dd>
      </dl>
        <img src="/images/green-ball.gif" height="12" width="12">
        <a name="obsolete_nec_pns"></a><b>obsolete_nec_pns</b>          
    
      <pre>&nbsp;&nbsp;&nbsp; FUNCTION obsolete_nec_pns(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cluster_flag IN INTEGER := MEME_CONSTANTS.CLUSTER_NO,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work_id IN INTEGER := 0);</pre>
                  
      <dl>
        <dd> Returns a table name containing a list of concepts with <tt>'%NEC
 in %'</tt> <tt>MTH/PN</tt> strings that contain obsolete source names.</dd>
      </dl>
   .</td>
   </tr>
         
  </tbody>  
</table>
  </center>
      
<p><i>Key</i> </p>
   
<blockquote>&nbsp;       
  <table width="70%" nosave="">
   <tbody>
        <tr nosave="">
   <td nosave=""><sup><font color="#3366ff"><font size="-2">(r)</font></font></sup></td>
    <td><b><font size="-1">Required</font></b></td>
    <td><font size="-1">QA bins produced from this function must be completely 
 edited.</font></td>
   </tr>
    <tr>
   <td><sup><font color="#3366ff"><font size="-2">(i)</font></font></sup></td>
    <td><b><font size="-1">IC Check</font></b></td>
    <td><font size="-1">This function implements an integrity check</font></td>
   </tr>
    <tr nosave="">
   <td nosave=""><sup><font color="#3366ff"><font size="-2">(u)</font></font></sup></td>
    <td><b><font size="-1">Untested</font></b></td>
    <td><font size="-1">This function is either unimplemented or untested</font></td>
   </tr>
             
    </tbody>      
  </table>
   </blockquote>
      
<hr width="100%">   
<table border="0" cols="2" width="100%" nosave="">
   <tbody>
      <tr nosave="">
   <td align="left" valign="top" nosave="">               
      <address> <a href="/MEME/">MEME Home</a></address>
   </td>
    <td align="right" valign="top" nosave="">               
      <address> <font size="-1">Contact: <a
 href="mailto:bcarlsen@apelon.com">Brian A. Carlsen</a></font></address>
                  
      <address> <font size="-1">Created: 7/19/2000</font></address>
                  
      <address> <font size="-1">Last Updated: 4/25/2003</font></address>
   </td>
   </tr>
         
  </tbody>  
</table>
 <!-- These comments are used by the What's new Generator --> <!-- Changed On: 2003/09/23 --> 
<!-- Changed by: Brian Carlsen --> <!-- Change Note: MEME - Developer Guides - PL/SQL Documentation - MEME_INTEGRITY_PROC --> 
<!-- Fresh for: 1 month -->           <br>
   <br>
</body>
</html>
